import { LyricType } from '../constants/LyricType';
import { LyricMachine, OnLyricListener } from '../internal/LyricMachine';
import { LyricModel } from '../model/LyricModel';
import { LyricsLineModel, Tone } from '../model/LyricsLineModel';
import { EventBus, LyricsEvents } from '../utils/EventBus';
import { LogUtils } from '../utils/LogUtils';

/**
 * Physical display line interface
 * Represents a physical display line after splitting a logical lyrics line
 */
interface DisplayLine {
  text: string;
  tones: Tone[];
  startTime: number;
  endTime: number;
}


/**
 * A custom component for displaying karaoke lyrics with various visual effects.
 * Supports features like highlighting current line, scrolling animations,
 * line wrapping, and touch interactions for seeking.
 */
@Component
export struct LyricsView {
  @Prop viewBackgroundColor: string = '#CE93D8'; // Configurable background color
  /** Text size for normal lyrics lines */
  @Prop textSize: number = 16;
  /** Text size for current line */
  @Prop currentLineTextSize: number = 20;
  /** Text color for current line's normal text */
  @Prop currentLineTextColor: string = '#FFFFFF';
  /** Text color for current line's highlighted portion */
  @Prop currentLineHighlightedTextColor: string = '#FF6B35';
  /** Text color for previous lyrics lines */
  @Prop previousLineTextColor: string = '#999999';
  /** Text color for upcoming lyrics lines */
  @Prop upcomingLineTextColor: string = '#999999';
  /** Vertical spacing between lyrics lines */
  @Prop lineSpacing: number = 12;
  /** Top padding for the entire lyrics view */
  @Prop paddingTop: number = 5;
  /** Text to display when no lyrics are available */
  @Prop labelWhenNoLyrics: string = 'æš‚æ— æ­Œè¯';
  /** Whether to enable automatic line wrapping for long lyrics */
  @Prop enableLineWrap: boolean = false;
  /** Whether dragging is enabled */
  @Prop enableDragging: boolean = true;
  /** Whether to enable opacity fade effect for top and bottom lyrics lines */
  @Prop enableOpacityEffect: boolean = true;
  /** Whether to show lyrics lines before the current line */
  @Prop enablePreviousLines: boolean = true;
  /** Whether to show lyrics lines after the current line */
  @Prop enableUpcomingLines: boolean = true;
  /** Whether to show the prelude end position indicator */
  @Prop enablePreludeEndPositionIndicator: boolean = true;
  /** Top padding for the prelude end position indicator */
  @Prop preludeEndPositionIndicatorPaddingTop: number = 3;
  /** Radius of the prelude end position indicator dots */
  @Prop preludeEndPositionIndicatorRadius: number = 4;
  /** Color of the prelude end position indicator */
  @Prop preludeEndPositionIndicatorColor: string = '#FF6B35';
  /** Horizontal alignment of lyrics text (0=center, 1=left, 2=right) */
  @Prop textGravity: number = 0;
  // Internal state
  /** Index of the currently displayed lyrics line */
  @State private mIndexOfCurrentLine: number = -1;
  /** Reactive copy of the lyrics model */
  @State private lyricsModel: LyricModel | null = null;
  /** Reactive array of lyrics lines */
  @State private lyricsLines: LyricsLineModel[] = [];
  /** Current timestamp in the lyrics playback */
  @State private mCurrentTime: number = 0;
  @State private mDraggingInProgress: boolean = false;
  @State private mCurrentLineTranslateX: number = 0;
  // Horizontal scrolling related state
  // Actual component dimensions measured dynamically
  @State private actualViewHeight: number = 400; // Default value, will be overridden by actual measurement
  @State private actualViewWidth: number = 300; // Default value, will be overridden by actual measurement
  // Drag related state
  @State private initialTouchY: number = 0; // Initial touch Y coordinate
  @State private dragLineOffset: number = 0; // Lyrics line offset during dragging
  @State private originalCurrentLineIndex: number = -1; // Original current line index when drag started
  // Animation state management
  @State private isAnimating: boolean = false;
  @State private animationKey: number = 0; // Used to force re-render animation
  @State private transitioningFromIndex: number = -1; // Index of the line transitioning from current
  @State private transitioningFromY: number = 0; // Starting Y position of transitioning line
  @State private transitioningToY: number = 0; // Target Y position of transitioning line
  @State private newCurrentTransitioning: boolean = false; // Whether new current line is transitioning
  @State private newCurrentFromY: number = 0; // Starting Y position of new current line
  @State private newCurrentToY: number = 0; // Target Y position of new current line
  @State private styleTransitioning: boolean = false; // Whether style is transitioning
  // Text scrolling related state
  @State private isTextScrolling: boolean = false; // Whether text is scrolling
  @State private textScrollTimer: number = -1; // Text scroll timer
  // Current line scroll offset state (for debug logging)
  @State private currentLineScrollOffset: number = 0;
  @State private linePaddingLeftRight: number = 20;
  /** The lyrics state machine managing lyrics progression */
  private mLyricMachine: LyricMachine | null = null;
  // Text scroll controller for horizontal scrolling
  private textScroller: Scroller = new Scroller();
  // Event bus instance for global communication
  private eventBus: EventBus = EventBus.getInstance();

  /**
   * Requests a refresh of the UI.
   * Updates the progress and triggers a redraw if necessary.
   */
  requestRefreshUi(): void {
    if (this.mLyricMachine) {
      // Synchronously update reactive state
      const currentModel = this.mLyricMachine.getLyricsModel();
      this.lyricsModel = currentModel;
      this.lyricsLines = currentModel?.lines || [];

      this.updateByProgress(this.mLyricMachine.getCurrentLyricProgress());
    }
  }

  /**
   * Resets the view to its initial state.
   * Clears all loaded lyrics and internal state.
   */
  reset(): void {

    this.resetInternal();
  }

  /**
   * Complete reset, including clearing LyricMachine reference
   * Only called when component is destroyed or needs complete cleanup
   */
  resetCompletely(): void {
    this.mLyricMachine = null;
    this.resetInternal();
  }

  /**
   * Checks if the lyrics view is uninitialized or has no lyrics data.
   * @return true if lyrics are not available or not initialized
   */
  private uninitializedOrNoLyrics(): boolean {
    const hasLyricMachine = !!this.mLyricMachine;
    const hasModel = !!this.lyricsModel;
    const hasLines = this.lyricsLines.length > 0;

    return !hasLyricMachine || !hasModel || !hasLines;
  }

  /**
   * Updates the view based on the current timestamp.
   * Handles line transitions and triggers animations when necessary.
   * @param timestamp Current playback position in milliseconds
   */
  private updateByProgress(timestamp: number): void {
    this.mCurrentTime = timestamp;
    const lyricsModel = this.mLyricMachine?.getLyricsModel();

    if (this.refreshNoLyrics()) {
      LogUtils.d('LyricsView: No lyrics available, showing no lyrics message');
      return;
    }

    const line = this.quickSearchLineByTimestamp(this.mCurrentTime);

    if (line < 0 || !lyricsModel || line >= lyricsModel.lines.length) {
      LogUtils.d('LyricsView: Invalid line index, no UI update needed');
      return;
    }

    if (line !== this.mIndexOfCurrentLine) {
      const oldLine = this.mIndexOfCurrentLine;

      // Stop previous line's text scrolling
      this.stopTextScrollAnimation();

      // Trigger line change animation
      this.triggerLineChangeAnimation(this.mIndexOfCurrentLine, line);

      this.mIndexOfCurrentLine = line;

      // Start new current line's text scrolling
      const lyricsModel = this.mLyricMachine?.getLyricsModel();
      if (lyricsModel && lyricsModel.lines && line >= 0 && line < lyricsModel.lines.length) {
        this.startTextScrollAnimation(lyricsModel.lines[line]);
      }
    }
  }

  /**
   * Refreshes the "No Lyrics" display state.
   * @return true if no lyrics are available and refresh was performed
   */
  private refreshNoLyrics(): boolean {
    return this.uninitializedOrNoLyrics();
  }

  /**
   * Performs binary search to find the lyrics line that should be displayed at the given timestamp.
   * @param time Current timestamp in milliseconds
   * @return Index of the lyrics line to display
   */
  private quickSearchLineByTimestamp(time: number): number {
    if (this.uninitializedOrNoLyrics()) {
      return 0;
    }

    let left = 0;
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel) {
      return 0;
    }
    let right = lyricsModel.lines.length - 1;

    while (left <= right) {
      const middle = Math.floor((left + right) / 2);
      const middleTime = lyricsModel.lines[middle].getStartTime();

      if (time < middleTime) {
        right = middle - 1;
      } else {
        if (middle + 1 >= lyricsModel.lines.length ||
          time < lyricsModel.lines[middle + 1].getStartTime()) {
          return middle;
        }
        left = middle + 1;
      }
    }

    return 0;
  }

  /**
   * Resets all internal state variables to their default values.
   */
  private resetInternal(): void {
    this.mCurrentTime = 0;
    this.mCurrentLineTranslateX = 0;
    this.mIndexOfCurrentLine = -1;

    this.lyricsModel = null;
    this.lyricsLines = [];
  }

  /**
   * Force check line wrap based on lyric type
   */
  private forceCheckLineWrap(): void {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines || lyricsModel.lines.length === 0) {
      return;
    }
    // if (lyricsModel.type === LyricType.LRC) {
    //   this.enableLineWrap = true;
    // }
  }

  /**
   * Renders the no lyrics state
   */
  @Builder
  NoLyricsBuilder() {
    Column() {
      Text(this.labelWhenNoLyrics)
        .fontSize(this.currentLineTextSize)
        .fontColor(this.currentLineHighlightedTextColor)
        .textAlign(this.getTextAlign())
    }
    .width('100%')
    .height('100%')
    .justifyContent(this.getRowJustifyContent())
  }

  /**
   * Gets the complete text of a lyrics line
   */
  private getLineText(line: LyricsLineModel): string {
    if (line.tones && line.tones.length > 0) {
      return line.tones.map(tone => tone.word).join('');
    }
    return '';
  }

  /**
   * Gets text alignment based on textGravity property
   */
  private getTextAlign(): TextAlign {
    switch (this.textGravity) {
      case 1:
        return TextAlign.Start; // left
      case 2:
        return TextAlign.End; // right
      default:
        return TextAlign.Center; // center
    }
  }

  /**
   * Gets Row alignment based on textGravity
   */
  private getRowJustifyContent(): FlexAlign {
    switch (this.textGravity) {
      case 1:
        return FlexAlign.Start; // left
      case 2:
        return FlexAlign.End; // right
      default:
        return FlexAlign.Center; // center
    }
  }

  /**
   * Gets Alignment based on textGravity
   */
  private getAlignment(): Alignment {
    switch (this.textGravity) {
      case 1:
        return Alignment.Start; // left
      case 2:
        return Alignment.End; // right
      default:
        return Alignment.Center; // center
    }
  }

  /**
   * Gets the countdown value for prelude indicator
   */
  private getPreludeCountDown(): number {
    if (!this.lyricsModel) {
      return 0;
    }
    return Math.ceil((this.lyricsModel.preludeEndPosition - this.mCurrentTime) / 1000);
  }

  /**
   * Triggers line change animation
   */
  private triggerLineChangeAnimation(fromLine: number, toLine: number): void {
    if (fromLine === toLine) {
      return;
    }

    // ğŸ¯ Disable animation during drag to avoid UI confusion
    if (this.mDraggingInProgress) {
      LogUtils.d(`LyricsView: Skip animation during drag - from ${fromLine} to ${toLine}`);
      return;
    }

    // ğŸ¯ When line jump exceeds 1 line (e.g., after drag setProgress jump), don't execute transition animation
    // Let target line directly change from normal line to current line, avoiding unnatural animation effects
    const lineJump = Math.abs(toLine - fromLine);
    if (lineJump > 1) {
      return;
    }

    this.isAnimating = true;
    this.transitioningFromIndex = fromLine; // Record original current line
    this.newCurrentTransitioning = true; // New current line starts transitioning
    this.styleTransitioning = false; // Style transition starts later

    // ğŸ¯ Fix jitter issue: Use dynamic line height calculation consistent with calculateLineYPosition
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    let currentLineHeight = this.getLineHeight(); // Default value

    if (lyricsModel && lyricsModel.lines && toLine >= 0 && toLine < lyricsModel.lines.length) {
      const currentLine = lyricsModel.lines[toLine];
      currentLineHeight = currentLine ?
      this.getDynamicLineHeight(currentLine, this.currentLineTextSize) :
      this.getLineHeight();
    }

    const centerY = (this.actualViewHeight / 2) - (currentLineHeight / 2);

    // === Original current line transition settings ===
    // Original current line starts from center position
    this.transitioningFromY = centerY;

    // ğŸ¯ Key fix: Use exactly the same logic as calculateLineYPosition to calculate transition line target position
    // Ensure position matches exactly after animation ends, avoiding jumps
    let oldTargetY = centerY;

    if (lyricsModel && lyricsModel.lines && fromLine < toLine) {
      // fromLine will become previous line, use same cumulative calculation logic as calculateLineYPosition
      let totalOffset = 0;
      for (let i = toLine - 1; i >= fromLine; i--) {
        const line = lyricsModel.lines[i];
        if (line) {
          const lineHeight = this.getDynamicLineHeight(line, i === toLine ? this.currentLineTextSize : this.textSize);
          totalOffset += lineHeight;
        }
      }
      oldTargetY = centerY - totalOffset;
    } else {
      // Use original simple calculation as fallback
      oldTargetY = centerY - currentLineHeight;
    }

    // ArkUI V2 optimization: More precise position calculation, avoiding overlap
    // Set starting position
    this.transitioningFromY = centerY; // Transition line starting position: center

    // ğŸ¯ V2 fix: New current line starting position more precise, avoiding overlap with transition line
    const nextLine = lyricsModel?.lines?.[toLine];
    const nextLineOffset = nextLine ?
      this.getDynamicLineHeight(nextLine, this.currentLineTextSize) + this.lineSpacing :
      this.getLineHeight() + this.lineSpacing;
    this.newCurrentFromY = centerY + nextLineOffset; // New current line starting position: ensure no overlap

    // Set target position
    this.transitioningToY = oldTargetY; // Transition line target position: previous line
    this.newCurrentToY = centerY; // New current line target position: center

    this.animationKey = Date.now(); // Update animation key to force re-render

    // ArkUI V2 optimization: Reduce delay, make animation more synchronized
    setTimeout(() => {
      if (this.isAnimating) {
        this.styleTransitioning = true; // Start style transition
      }
    }, 50); // V2 optimization: Reduce delay to 50ms, make animation more synchronized

    // Clear state after animation completes
    setTimeout(() => {
      this.isAnimating = false;
      this.transitioningFromIndex = -1; // Clear transition state
      this.newCurrentTransitioning = false; // Clear new current line transition state
      this.styleTransitioning = false; // Clear style transition state
    }, 400); // V2 optimization: Adjust total duration to 400ms, matching animation duration
  }

  /**
   * Calculates line animation delay (staggered animation)
   */
  private getAnimationDelay(index: number): number {
    if (!this.isAnimating) {
      return 0; // No delay in non-animation state
    }

    const distance = Math.abs(index - this.mIndexOfCurrentLine);
    // Current line has no delay, other lines have increasing delay based on distance
    if (distance === 0) {
      return 0; // Current line starts animation immediately
    } else {
      // Farther distance means larger delay, but use smaller increment to avoid excessive delay
      return Math.min(distance * 15, 80); // Maximum 80ms delay
    }
  }

  /**
   * Calculates Y position of lyrics line (simplified version, using basic spacing)
   */
  private calculateLineYPosition(index: number): number {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines || index < 0 || index >= lyricsModel.lines.length) {
      return 0;
    }

    // ğŸ¯ Important note: Transition line and new current line positions are directly controlled by their respective Builders
    // TransitioningHighlightLineBuilder uses getTransitioningYPosition()
    // NewCurrentLineTransitionBuilder uses getNewCurrentYPosition()
    // This calculateLineYPosition only handles normal line position calculation

    // Unified position calculation logic
    let currentLineIndex = this.mIndexOfCurrentLine;
    let additionalOffset = 0;

    // Get actual height of current line for center calculation
    const currentLine = lyricsModel.lines[currentLineIndex];
    const currentLineHeight = currentLine ?
    this.getDynamicLineHeight(currentLine, this.currentLineTextSize) :
    this.getLineHeight();
    const centerY = (this.actualViewHeight / 2) - (currentLineHeight / 2);

    if (this.mDraggingInProgress && this.originalCurrentLineIndex >= 0) {
      // ğŸ¯ During drag, implement scrolling list effect: calculate virtual current line, but don't use animation transition
      // This allows showing different lyrics content while avoiding UI confusion during drag
      const virtualCurrentLineIndex = this.originalCurrentLineIndex - this.dragLineOffset;
      const clampedVirtualIndex = Math.max(0, Math.min(virtualCurrentLineIndex,
        (lyricsModel?.lines?.length || 1) - 1));

      currentLineIndex = clampedVirtualIndex;
      additionalOffset = 0; // Use virtual current line for re-layout, no additional offset needed
    }

    // Dynamic position calculation: accumulate actual height of each line
    let yPosition = centerY;

    if (index === currentLineIndex) {
      // Current line: at center position
      yPosition = centerY + additionalOffset;

    } else if (index < currentLineIndex) {
      // Lines above: accumulate upward offset
      let totalOffset = 0;
      for (let i = currentLineIndex - 1; i >= index; i--) {
        const line = lyricsModel.lines[i];
        if (line) {
          const lineHeight = this.getDynamicLineHeight(line, this.textSize);
          totalOffset += lineHeight;
        }
      }
      yPosition = centerY - totalOffset + additionalOffset;
    } else {
      // Lines below: accumulate downward offset
      let totalOffset = currentLineHeight; // Start from bottom of current line
      for (let i = currentLineIndex + 1; i <= index; i++) {
        const line = lyricsModel.lines[i];
        if (line) {
          const lineHeight = this.getDynamicLineHeight(line, this.textSize);
          if (i === index) {
            // Target line: don't add its own height, because yPosition is top position
            break;
          }
          totalOffset += lineHeight;
        }
      }
      yPosition = centerY + totalOffset + additionalOffset;
    }

    // Boundary check logic
    const targetLine = lyricsModel.lines[index];
    const targetLineHeight = targetLine ?
    this.getDynamicLineHeight(targetLine,
      index === this.mIndexOfCurrentLine ? this.currentLineTextSize : this.textSize) :
    this.getLineHeight();

    // ğŸ¯ Fix boundary limits: set different boundary ranges for different types of lines
    let minY: number;
    let maxY: number;

    if (index < currentLineIndex) {
      // Sung lines (above): allow larger upward expansion range
      minY = -this.actualViewHeight * 2; // Allow upward expansion to 2x screen height
      maxY = centerY; // Lowest not exceeding center position
    } else if (index > currentLineIndex) {
      // Unsung lines (below): allow larger downward expansion range
      minY = centerY; // Highest not exceeding center position
      maxY = this.actualViewHeight * 3; // Allow downward expansion to 3x screen height
    } else {
      // Current line: use original boundary limits
      minY = -targetLineHeight * 0.5;
      maxY = this.actualViewHeight + targetLineHeight * 0.5;
    }

    // ğŸ¯ Smart boundary control during drag:
    // - Original current line (may move from center to top or bottom) allows complete movement out of view
    // - Other lines still need boundary limits to prevent interface confusion
    if (this.mDraggingInProgress) {
      if (index === this.originalCurrentLineIndex) {
        // Original current line allows movement out of view, achieving true scrolling effect
        return yPosition;
      } else {
        // Other lines still subject to boundary limits, preventing display confusion
        const clampedY = Math.max(minY, Math.min(maxY, yPosition));
        return clampedY;
      }
    }

    // Standard boundary check for non-drag state
    const clampedY = Math.max(minY, Math.min(maxY, yPosition));

    return clampedY;
  }

  /**
   * Calculates lyrics line height
   */
  private getLineHeight(): number {
    return this.currentLineTextSize + this.lineSpacing;
  }

  /**
   * Dynamically calculates actual display height of specific lyrics line
   * Only increases height when text really needs multiple lines
   */
  private getDynamicLineHeight(line: LyricsLineModel, fontSize: number): number {
    if (!this.shouldEnableLineWrap() || !line) {
      return fontSize + this.lineSpacing;
    }

    const text = this.getLineText(line);
    if (!text || text.length === 0) {
      return fontSize + this.lineSpacing;
    }

    // Estimate text width
    const textWidth = this.measureTextWidth(text, fontSize);
    const availableWidth = this.actualViewWidth;

    if (availableWidth <= 0 || textWidth <= availableWidth) {
      // Can be displayed in one line, use standard line height
      return fontSize + this.lineSpacing;
    } else {
      // Needs multiple lines, calculate actual required line count
      const estimatedLines = Math.ceil(textWidth / availableWidth);
      const actualLines = Math.min(estimatedLines, 3); // Maximum 3 lines
      return (fontSize * actualLines) + this.lineSpacing;
    }
  }

  /**
   * Splits lyrics line into multiple physical lines based on display width
   */
  private splitLineIntoDisplayLines(line: LyricsLineModel, fontSize: number): DisplayLine[] {
    if (!this.shouldEnableLineWrap() || !line || !line.tones || line.tones.length === 0) {
      return [{
        text: this.getLineText(line),
        tones: line.tones || [],
        startTime: line.getStartTime(),
        endTime: line.getEndTime()
      }];
    }

    const availableWidth = this.actualViewWidth;
    if (availableWidth <= 0) {
      return [{
        text: this.getLineText(line),
        tones: line.tones || [],
        startTime: line.getStartTime(),
        endTime: line.getEndTime()
      }];
    }

    const result: DisplayLine[] = [];
    let currentLineText = '';
    let currentLineTones: Tone[] = [];
    let currentLineStartTime = line.getStartTime();
    let currentLineEndTime = line.getStartTime();

    for (let i = 0; i < line.tones.length; i++) {
      const tone = line.tones[i];
      const testText = currentLineText + tone.word;
      const testWidth = this.measureTextWidth(testText, fontSize);

      if (testWidth <= availableWidth || currentLineText === '') {
        // å½“å‰è¡Œè¿˜èƒ½å®¹çº³è¿™ä¸ªå­—ç¬¦ï¼Œæˆ–è€…è¿™æ˜¯ç¬¬ä¸€ä¸ªå­—ç¬¦
        currentLineText += tone.word;
        currentLineTones.push(tone);
        currentLineEndTime = tone.end;
      } else {
        // å½“å‰è¡Œå·²æ»¡ï¼Œå¼€å§‹æ–°è¡Œ
        if (currentLineText !== '') {
          result.push({
            text: currentLineText,
            tones: [...currentLineTones],
            startTime: currentLineStartTime,
            endTime: currentLineEndTime
          });
        }

        // å¼€å§‹æ–°è¡Œ
        currentLineText = tone.word;
        currentLineTones = [tone];
        currentLineStartTime = tone.begin;
        currentLineEndTime = tone.end;
      }
    }

    // æ·»åŠ æœ€åä¸€è¡Œ
    if (currentLineText !== '') {
      result.push({
        text: currentLineText,
        tones: [...currentLineTones],
        startTime: currentLineStartTime,
        endTime: currentLineEndTime
      });
    }

    return result.length > 0 ? result : [{
      text: this.getLineText(line),
      tones: line.tones || [],
      startTime: line.getStartTime(),
      endTime: line.getEndTime()
    }];
  }

  /**
   * è®¡ç®—å¤šè¡Œæ­Œè¯ä¸­ç‰¹å®šç‰©ç†è¡Œçš„é«˜äº®è¿›åº¦
   */
  private calculateDisplayLineProgress(displayLine: DisplayLine, currentTime: number): number {
    if (!displayLine.tones || displayLine.tones.length === 0) {
      return 0;
    }

    if (currentTime < displayLine.startTime) {
      return 0;
    }

    if (currentTime >= displayLine.endTime) {
      return 1;
    }

    // åœ¨è¿™ä¸ªç‰©ç†è¡Œçš„æ—¶é—´èŒƒå›´å†…ï¼Œè®¡ç®—å­—ç¬¦çº§åˆ«çš„è¿›åº¦
    let highlightedChars = 0;
    for (const tone of displayLine.tones) {
      if (currentTime >= tone.end) {
        highlightedChars += tone.word.length;
      } else if (currentTime >= tone.begin) {
        // éƒ¨åˆ†é«˜äº®å½“å‰å­—ç¬¦
        const charProgress = (currentTime - tone.begin) / (tone.end - tone.begin);
        highlightedChars += tone.word.length * charProgress;
        break;
      } else {
        break;
      }
    }

    return Math.min(highlightedChars / displayLine.text.length, 1);
  }

  /**
   * æ”¹è¿›çš„æ–‡æœ¬å®½åº¦ä¼°ç®—æ–¹æ³•
   * æ ¹æ®å­—ç¬¦ç±»å‹è¿›è¡Œæ›´ç²¾ç¡®çš„ä¼°ç®—ï¼Œå¹¶æ·»åŠ å®‰å…¨è¾¹è·
   */
  private measureTextWidth(text: string, fontSize: number): number {
    let estimatedWidth = 0;
    let isChinese = false;

    for (let i = 0; i < text.length; i++) {
      const char = text.charAt(i);
      if (/[\u4e00-\u9fa5]/.test(char)) {
        // ä¸­æ–‡å­—ç¬¦ï¼Œå®½åº¦çº¦ç­‰äºå­—ä½“å¤§å°
        estimatedWidth += fontSize;
        isChinese = true;
      } else if (/[a-zA-Z0-9]/.test(char)) {
        // è‹±æ–‡å­—æ¯å’Œæ•°å­—ï¼Œå®½åº¦çº¦ä¸ºå­—ä½“å¤§å°çš„0.6å€ï¼ˆç¨å¾®å¢åŠ ä»¥ç¡®ä¿å‡†ç¡®æ€§ï¼‰
        estimatedWidth += fontSize * 0.6;
      } else {
        // æ ‡ç‚¹ç¬¦å·å’Œå…¶ä»–å­—ç¬¦
        if (isChinese) {
          estimatedWidth += fontSize * 0.8; // ä¸­æ–‡æ ‡ç‚¹ç¬¦å·
        } else {
          estimatedWidth += fontSize * 0.4; // è‹±æ–‡æ ‡ç‚¹ç¬¦å·
        }
      }
    }

    // ä¸ºè‹±æ–‡æ–‡æœ¬æ·»åŠ é¢å¤–çš„å®‰å…¨è¾¹è·ï¼Œå› ä¸ºè‹±æ–‡å­—ç¬¦é—´è·å’Œå­—ä½“æ¸²æŸ“å¯èƒ½æœ‰å·®å¼‚
    if (!isChinese && text.length > 0) {
      estimatedWidth *= 1.1; // å¢åŠ 10%çš„å®‰å…¨è¾¹è·
    }

    return estimatedWidth;
  }

  /**
   * æ£€æµ‹æ–‡æœ¬æ˜¯å¦éœ€è¦æ»šåŠ¨ï¼ˆè¶…å‡ºå®¹å™¨å®½åº¦ï¼‰
   */
  private isTextOverflowing(text: string, fontSize: number): boolean {
    const actualTextWidth = this.measureTextWidth(text, fontSize);
    // è€ƒè™‘å·¦å³è¾¹è·ï¼Œå®é™…å¯ç”¨å®½åº¦è¦å‡å»è¾¹è·
    const availableWidth = this.actualViewWidth - (this.linePaddingLeftRight * 2);
    const isOverflowing = actualTextWidth > availableWidth;

    // ä¸ºäº†æµ‹è¯•ï¼Œé™ä½æ»šåŠ¨è§¦å‘é˜ˆå€¼
    if (!this.shouldEnableLineWrap()) {
      // å¯¹äºä¸æ¢è¡Œæ¨¡å¼ï¼Œå¦‚æœæ–‡æœ¬é•¿åº¦è¶…è¿‡5ä¸ªå­—ç¬¦å°±è®¤ä¸ºéœ€è¦æ»šåŠ¨ï¼ˆä¾¿äºæµ‹è¯•ï¼‰
      if (text.length > 5) {
        return true;
      }
    }

    return isOverflowing;
  }

  /**
   * è®¡ç®—æ–‡æœ¬æ»šåŠ¨åç§»é‡
   * è®©æ­£åœ¨æ’­æ”¾çš„éƒ¨åˆ†å§‹ç»ˆä¿æŒåœ¨è§†å›¾ä¸­å¤®
   */
  private calculateTextScrollOffset(line: LyricsLineModel, progress: number): number {
    const text = this.getLineText(line);
    const fontSize = this.currentLineTextSize; // ç¡®ä¿ä½¿ç”¨å½“å‰è¡Œå­—ä½“å¤§å°
    const actualTextWidth = this.measureTextWidth(text, fontSize); // ä½¿ç”¨ç²¾ç¡®æµ‹é‡
    // è€ƒè™‘å·¦å³è¾¹è·ï¼Œå®é™…å¯ç”¨å®½åº¦è¦å‡å»è¾¹è·
    const containerWidth = this.actualViewWidth - (this.linePaddingLeftRight * 2);

    // ä¸ºäº†æµ‹è¯•ï¼Œå³ä½¿æ–‡æœ¬ä¸æ˜¯å¾ˆé•¿ä¹Ÿå…è®¸æ»šåŠ¨
    if (actualTextWidth <= containerWidth * 0.8) { // é™ä½é˜ˆå€¼ï¼Œ80%å°±å¼€å§‹æ»šåŠ¨
      return 0; // æ–‡æœ¬ä¸å¤Ÿé•¿ï¼Œæ— éœ€æ»šåŠ¨
    }

    // è®¡ç®—å½“å‰æ’­æ”¾ä½ç½®çš„åƒç´ åç§»
    const currentPlayPosition = actualTextWidth * progress;
    const halfContainerWidth = containerWidth / 2;

    // è®©å½“å‰æ’­æ”¾ä½ç½®ä¿æŒåœ¨å®¹å™¨ä¸­å¤®
    let targetOffset = currentPlayPosition - halfContainerWidth;

    // é™åˆ¶æ»šåŠ¨èŒƒå›´ï¼šä¸èƒ½æ»šåŠ¨åˆ°è´Ÿå€¼ï¼Œä¹Ÿä¸èƒ½è¶…è¿‡æœ€å¤§æ»šåŠ¨è·ç¦»
    const maxScrollOffset = actualTextWidth - containerWidth;
    targetOffset = Math.max(0, Math.min(targetOffset, maxScrollOffset));

    return targetOffset;
  }

  /**
   * å¯åŠ¨æ–‡æœ¬æ»šåŠ¨åŠ¨ç”»
   */
  private startTextScrollAnimation(line: LyricsLineModel): void {
    const text = this.getLineText(line);

    // é‡ç½®æ»šåŠ¨åç§»ï¼Œä¸ºæ–°è¡Œå‡†å¤‡
    this.currentLineScrollOffset = 0;

    if (this.shouldEnableLineWrap()) {
      return; // å¯ç”¨æ¢è¡Œæ—¶ä¸éœ€è¦æ»šåŠ¨
    }

    if (!this.isTextOverflowing(text, this.currentLineTextSize)) {
      return; // æ–‡æœ¬ä¸è¶…é•¿æ—¶ä¸éœ€è¦æ»šåŠ¨
    }

    this.isTextScrolling = true;

    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (this.textScrollTimer !== -1) {
      clearInterval(this.textScrollTimer);
    }

    // å¯åŠ¨æ»šåŠ¨å®šæ—¶å™¨ï¼Œæ¯50msæ›´æ–°ä¸€æ¬¡ä»¥è·å¾—æ›´æµç•…çš„æ•ˆæœ
    this.textScrollTimer = setInterval(() => {
      if (!this.isTextScrolling) {
        return;
      }

      const progress = this.calculateLineProgress(line);
      const targetOffset = this.calculateTextScrollOffset(line, progress);

      // ä½¿ç”¨textScroller.scrollToå®ç°çœŸæ­£çš„æ»šåŠ¨
      if (Math.abs(this.currentLineScrollOffset - targetOffset) > 0.5) {
        const oldOffset = this.currentLineScrollOffset;
        this.currentLineScrollOffset = targetOffset;

        // ä½¿ç”¨Scrollerè¿›è¡Œæ»šåŠ¨
        this.textScroller.scrollTo({
          xOffset: targetOffset,
          yOffset: 0,
          animation: {
            duration: 100,
            curve: Curve.EaseOut
          }
        });
      }
    }, 50);
  }

  /**
   * åœæ­¢æ–‡æœ¬æ»šåŠ¨åŠ¨ç”»
   */
  private stopTextScrollAnimation(): void {
    if (this.textScrollTimer !== -1) {
      clearInterval(this.textScrollTimer);
      this.textScrollTimer = -1;
    }
    this.isTextScrolling = false;
    this.mCurrentLineTranslateX = 0; // é‡ç½®æ°´å¹³æ»šåŠ¨åç§»
    // é‡ç½®æ»šåŠ¨ä½ç½®åˆ°å¼€å§‹
    this.textScroller.scrollTo({
      xOffset: 0,
      yOffset: 0
    });
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦åº”ç”¨æ¨ªå‘æ»šåŠ¨ï¼ˆå‚è€ƒAndroidç‰ˆæœ¬å®ç°ï¼‰
   * å½“é«˜äº®éƒ¨åˆ†å’Œå‰©ä½™éƒ¨åˆ†éƒ½å¤§äºè§†å›¾å®½åº¦çš„ä¸€åŠæ—¶ï¼Œå¼€å§‹æ»šåŠ¨
   */
  private checkIfXTranslationShouldApply(line: LyricsLineModel): void {
    if (this.shouldEnableLineWrap()) {
      this.mCurrentLineTranslateX = 0; // æ¢è¡Œæ¨¡å¼ä¸‹ä¸éœ€è¦æ¨ªå‘æ»šåŠ¨
      this.updateScrollPosition(0);
      return;
    }

    const text = this.getLineText(line);
    const fontSize = this.currentLineTextSize;
    const textWidth = text.length * fontSize * 0.6; // ä¼°ç®—æ–‡æœ¬æ€»å®½åº¦
    const viewWidth = this.actualViewWidth;
    const halfViewWidth = viewWidth / 2;

    // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦è¶…é•¿
    if (!this.isLyricsLineOverlong(textWidth)) {
      this.mCurrentLineTranslateX = 0;
      this.updateScrollPosition(0);
      return;
    }

    // è®¡ç®—å½“å‰é«˜äº®åŒºåŸŸå®½åº¦
    const progress = this.calculateLineProgress(line);
    const currentHighlightWidth = textWidth * progress;

    // Androidç‰ˆæœ¬çš„æ»šåŠ¨é€»è¾‘ï¼š
    // 1. é«˜äº®éƒ¨åˆ†å¤§äºè§†å›¾å®½åº¦çš„ä¸€åŠ
    // 2. å‰©ä½™éƒ¨åˆ†ä¹Ÿå¤§äºè§†å›¾å®½åº¦çš„ä¸€åŠ
    if (currentHighlightWidth > halfViewWidth &&
      (textWidth - currentHighlightWidth) > halfViewWidth) {

      // è®¡ç®—ç›®æ ‡æ»šåŠ¨ä½ç½®ï¼šè®©å½“å‰æ’­æ”¾ä½ç½®ä¿æŒåœ¨å±å¹•ä¸­å¤®
      const targetScrollX = currentHighlightWidth - halfViewWidth;

      // é™åˆ¶æ»šåŠ¨èŒƒå›´
      const maxScroll = textWidth - viewWidth;
      this.mCurrentLineTranslateX = Math.max(0, Math.min(maxScroll, targetScrollX));

      // åº”ç”¨æ»šåŠ¨
      this.updateScrollPosition(this.mCurrentLineTranslateX);

    } else {
      this.mCurrentLineTranslateX = 0;
      this.updateScrollPosition(0);
    }
  }

  /**
   * æ›´æ–°æ»šåŠ¨ä½ç½®
   */
  private updateScrollPosition(scrollX: number): void {
    if (this.textScroller) {
      this.textScroller.scrollTo({
        xOffset: scrollX,
        yOffset: 0
      });
    }
  }

  /**
   * æ£€æŸ¥æ­Œè¯è¡Œæ˜¯å¦è¶…é•¿ï¼ˆéœ€è¦æ¨ªå‘æ»šåŠ¨ï¼‰
   */
  private isLyricsLineOverlong(textWidth: number): boolean {
    return textWidth > this.actualViewWidth;
  }

  /**
   * è®¡ç®—å¯ä»¥æ˜¾ç¤ºçš„æœ€å¤§è¡Œæ•°ï¼ˆä¸Šä¸‹å„ä¸€åŠï¼‰
   */
  private getMaxVisibleLines(): number {
    const lineHeight = this.getLineHeight();
    const availableHeight = this.actualViewHeight;
    return Math.floor(availableHeight / lineHeight);
  }

  /**
   * åˆ¤æ–­æ­Œè¯è¡Œæ˜¯å¦åœ¨å¯è§†èŒƒå›´å†…
   */
  private isLineVisible(index: number): boolean {
    // è®¡ç®—è¯¥è¡Œçš„å®é™…Yä½ç½®
    const lineY = this.calculateLineYPosition(index);
    const lineHeight = this.getLineHeight();

    // åˆ¤æ–­è¡Œæ˜¯å¦åœ¨è§†å›¾èŒƒå›´å†…ï¼ˆåŒ…å«éƒ¨åˆ†å¯è§ï¼‰
    const lineTop = lineY;
    const lineBottom = lineY + lineHeight;
    const viewTop = -lineHeight * 0.5; // å…è®¸ç¨å¾®è¶…å‡ºä¸Šè¾¹ç•Œ
    const viewBottom = this.actualViewHeight + lineHeight * 0.5; // å…è®¸ç¨å¾®è¶…å‡ºä¸‹è¾¹ç•Œ

    // å¦‚æœè¡Œçš„ä»»ä½•éƒ¨åˆ†åœ¨æ‰©å±•è§†å›¾èŒƒå›´å†…ï¼Œå°±è®¤ä¸ºæ˜¯å¯è§çš„
    const isVisible = lineBottom > viewTop && lineTop < viewBottom;

    return isVisible;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥æ¸²æŸ“æŸä¸€è¡Œï¼ˆåŸºäºenablePreviousLineså’ŒenableUpcomingLineså¼€å…³ï¼‰
   */
  private shouldRenderLine(index: number): boolean {
    // ç¡®å®šå½“å‰å‚è€ƒè¡Œç´¢å¼•
    let currentIndex = this.mIndexOfCurrentLine;

    if (this.mDraggingInProgress && this.originalCurrentLineIndex >= 0) {
      // ğŸ¯ æ‹–æ‹½æ—¶ä½¿ç”¨è™šæ‹Ÿå½“å‰è¡Œç´¢å¼•ï¼Œå®ç°æ»šåŠ¨åˆ—è¡¨æ•ˆæœ
      const lyricsModel = this.mLyricMachine?.getLyricsModel();
      const virtualCurrentLineIndex = this.originalCurrentLineIndex - this.dragLineOffset;
      currentIndex = Math.max(0, Math.min(virtualCurrentLineIndex,
        (lyricsModel?.lines?.length || 1) - 1));
    }

    // å½“å‰è¡Œå§‹ç»ˆæ¸²æŸ“
    if (index === currentIndex) {
      return true;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¹‹å‰çš„è¡Œ
    if (index < currentIndex) {
      return this.enablePreviousLines;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯æœªæ¥çš„è¡Œ
    if (index > currentIndex) {
      return this.enableUpcomingLines;
    }

    return true;
  }

  /**
   * ç»Ÿè®¡å¹¶è®°å½•å½“å‰å¯è§çš„è¡Œæ•°ï¼ˆè°ƒè¯•ç”¨ï¼‰
   */
  private logVisibleLinesCount(): void {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines) {
      return;
    }

    const visibleLines: number[] = [];
    const renderedLines: number[] = [];

    for (let i = 0; i < lyricsModel.lines.length; i++) {
      if (this.shouldRenderLine(i)) {
        renderedLines.push(i);

        if (this.isLineVisible(i)) {
          visibleLines.push(i);
        }
      }
    }
  }

  /**
   * æ¸è¿›å¼é«˜äº®æ­Œè¯è¡ŒBuilder - å®ç°å¡æ‹‰OKé£æ ¼çš„æµç•…é«˜äº®æ•ˆæœ
   */
  @Builder
  EnhancedLyricsLineBuilder(line: LyricsLineModel, index: number) {
    if (this.isLineVisible(index)) {
      // æ¸²æŸ“æ‰€æœ‰è¡Œï¼Œä½†ä½¿ç”¨é€æ˜åº¦æ§åˆ¶å¯è§æ€§ï¼Œç¡®ä¿åŠ¨ç”»è¿ç»­æ€§
      if (index === this.mIndexOfCurrentLine && this.newCurrentTransitioning) {
        // æ–°å½“å‰è¡Œæ­£åœ¨è¿‡æ¸¡ï¼šä½¿ç”¨æ–°å½“å‰è¡Œè¿‡æ¸¡æ•ˆæœ
        this.NewCurrentLineTransitionBuilder(line, index)
      } else if (index === this.mIndexOfCurrentLine) {
        // å½“å‰è¡Œï¼šä½¿ç”¨æ¸è¿›å¼é«˜äº®æ•ˆæœ
        this.ProgressiveHighlightLineBuilder(line, index)
      } else if (index === this.transitioningFromIndex && this.isAnimating) {
        this.TransitioningHighlightLineBuilder(line, index)
      } else {
        this.NormalLineBuilder(line, index)
      }
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åº”è¯¥å¯ç”¨æ¢è¡Œï¼ˆLRCæ ¼å¼é»˜è®¤å¯ç”¨ï¼‰
   */
  private shouldEnableLineWrap(): boolean {
    // å¦‚æœæ˜ç¡®è®¾ç½®äº†enableLineWrapï¼Œä½¿ç”¨è®¾ç½®å€¼
    if (this.enableLineWrap !== undefined) {
      return this.enableLineWrap;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯LRCæ ¼å¼ï¼ˆé€šè¿‡æ£€æŸ¥æ­Œè¯æ¨¡å‹çš„ç±»å‹ï¼‰
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (lyricsModel && lyricsModel.type === LyricType.LRC) {
      return true; // LRCæ ¼å¼é»˜è®¤å¯ç”¨æ¢è¡Œ
    }

    return false; // å…¶ä»–æ ¼å¼é»˜è®¤ä¸å¯ç”¨æ¢è¡Œ
  }

  /**
   * æ¸è¿›å¼é«˜äº®è¡ŒBuilder
   */
  @Builder
  ProgressiveHighlightLineBuilder(line: LyricsLineModel, index: number) {
    if (this.shouldEnableLineWrap()) {
      // å¯ç”¨æ¢è¡Œæ¨¡å¼
      this.WrappedHighlightLineBuilder(line, index);
    } else {
      // æ»šåŠ¨æ¨¡å¼
      this.ScrollingHighlightLineBuilder(line, index);
    }
  }

  /**
   * æ¢è¡Œé«˜äº®è¡ŒBuilder
   */
  @Builder
  WrappedHighlightLineBuilder(line: LyricsLineModel, index: number) {
    Stack() {
      // èƒŒæ™¯æ–‡å­—ï¼ˆæ­£å¸¸é¢œè‰²ï¼‰
      Column() {
        ForEach(this.splitLineIntoDisplayLines(line, this.currentLineTextSize),
          (displayLine: DisplayLine, displayIndex: number) => {
            Row() {
              Text(displayLine.text)
                .fontSize(this.currentLineTextSize)
                .fontColor(this.currentLineTextColor)
                .fontWeight(FontWeight.Bold)
                .textAlign(this.getTextAlign())
                .width('100%')
                .maxLines(1) // æ¯ä¸ªç‰©ç†è¡Œéƒ½æ˜¯å•è¡Œ
                .textOverflow({ overflow: TextOverflow.None })
            }
            .width('100%')
            .justifyContent(this.getRowJustifyContent())
            .height(this.currentLineTextSize)
          }, (displayLine: DisplayLine, displayIndex: number) => `${index}_bg_${displayIndex}`)
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)

      // é«˜äº®æ–‡å­—ï¼ˆé€è¡Œæ¸è¿›é«˜äº®ï¼‰
      Column() {
        ForEach(this.splitLineIntoDisplayLines(line, this.currentLineTextSize),
          (displayLine: DisplayLine, displayIndex: number) => {
            Row() {
              Text(displayLine.text)
                .fontSize(this.currentLineTextSize)
                .fontColor(this.currentLineHighlightedTextColor)
                .fontWeight(FontWeight.Bold)
                .textAlign(this.getTextAlign())
                .width('100%')
                .maxLines(1) // æ¯ä¸ªç‰©ç†è¡Œéƒ½æ˜¯å•è¡Œ
                .textOverflow({ overflow: TextOverflow.None })
            }
            .width('100%')
            .justifyContent(this.getRowJustifyContent())
            .height(this.currentLineTextSize)
            .clip(true)
            .clipShape(new Rect({
              width: `${this.calculateDisplayLineProgress(displayLine, this.mCurrentTime) * 100}%`,
              height: '100%'
            }))
            .animation({
              duration: 50, // æ›´å¿«çš„é«˜äº®å“åº”
              curve: Curve.Linear,
              iterations: 1,
              playMode: PlayMode.Normal
            })
          }, (displayLine: DisplayLine, displayIndex: number) => `${index}_fg_${displayIndex}`)
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
    }
    .width(this.actualViewWidth)
    .height(this.getDynamicLineHeight(line, this.currentLineTextSize))
    .position({ x: this.linePaddingLeftRight, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * æ»šåŠ¨é«˜äº®è¡ŒBuilderï¼ˆå•è¡Œæ˜¾ç¤ºï¼Œæ”¯æŒæ¨ªå‘æ»šåŠ¨åŠ¨ç”»ï¼‰
   */
  @Builder
  ScrollingHighlightLineBuilder(line: LyricsLineModel, index: number) {
    // ä½¿ç”¨Scrollç»„ä»¶å®ç°çœŸæ­£çš„æ¨ªå‘æ»šåŠ¨
    Scroll(this.textScroller) {
      Stack() {
        // èƒŒæ™¯æ–‡å­—ï¼ˆæ­£å¸¸é¢œè‰²ï¼Œå•è¡Œæ˜¾ç¤ºï¼‰
        Text(this.getLineText(line))
          .fontSize(this.currentLineTextSize)
          .fontColor(this.currentLineTextColor)
          .fontWeight(FontWeight.Bold)
          .textAlign(this.getTextAlign())
          .maxLines(1) // å•è¡Œæ˜¾ç¤º
          .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
          .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
          .onAppear(() => {
          })

        // é«˜äº®æ–‡å­—ï¼ˆä½¿ç”¨clipå®ç°æ¸è¿›æ•ˆæœï¼‰
        Text(this.getLineText(line))
          .fontSize(this.currentLineTextSize)
          .fontColor(this.currentLineHighlightedTextColor)
          .fontWeight(FontWeight.Bold)
          .textAlign(this.getTextAlign())
          .maxLines(1) // å•è¡Œæ˜¾ç¤º
          .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
          .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
          .clip(true)
          .clipShape(new Rect({
            width: `${this.calculateLineProgress(line) * 100}%`, // ä½¿ç”¨ç™¾åˆ†æ¯”ç¡®ä¿æ­£ç¡®å¯¹é½
            height: '100%'
          }))
          .animation({
            duration: 50, // æ›´å¿«çš„é«˜äº®å“åº”
            curve: Curve.Linear,
            iterations: 1,
            playMode: PlayMode.Normal
          })
      }
      .alignContent(this.getAlignment())
    }
    .scrollable(ScrollDirection.Horizontal) // æ°´å¹³æ»šåŠ¨
    .scrollBar(BarState.Off) // éšè—æ»šåŠ¨æ¡
    .width(this.actualViewWidth)
    .height(this.getLineHeight())
    .position({ x: this.linePaddingLeftRight, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * è¿‡æ¸¡æ™®é€šè¡ŒBuilder - å¤„ç†åŸå½“å‰è¡Œä»¥æ™®é€šè¡Œæ ·å¼ä»å½“å‰ä½ç½®ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
   */
  @Builder
  TransitioningHighlightLineBuilder(line: LyricsLineModel, index: number) {
    // æ ¹æ®enableLineWrapå†³å®šæ˜¾ç¤ºæ–¹å¼
    if (this.shouldEnableLineWrap()) {
      // æ¢è¡Œæ¨¡å¼ï¼šæ”¯æŒå¤šè¡Œæ˜¾ç¤º
      Row() {
        Text(this.getLineText(line))
          .fontSize(this.getTransitioningHighlightLineTextSize()) // ä¿æŒå½“å‰è¡Œå­—ä½“å¤§å°ï¼Œé€šè¿‡ç¼©æ”¾å®ç°å¤§å°å˜åŒ–
          .fontColor(this.getTransitioningHighlightLineTextColor()) // ä½¿ç”¨åŠ¨æ€é¢œè‰²
          .fontWeight(this.getTransitioningHighlightLineFontWeight()) // ä¿æŒå½“å‰è¡Œå­—é‡
          .textAlign(this.getTextAlign())
          .width('100%')
          .maxLines(3) // æœ€å¤š3è¡Œ
          .textOverflow({ overflow: TextOverflow.Ellipsis })
      }
      .width(this.actualViewWidth)
      .height(this.getDynamicLineHeight(line, this.currentLineTextSize))
      .justifyContent(this.getRowJustifyContent())
      .alignItems(VerticalAlign.Center)
      .position({
        x: this.linePaddingLeftRight,
        y: this.getTransitioningYPosition() // ä½¿ç”¨åŠ¨ç”»æ’å€¼ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getTransitioningScale(index),
        y: this.getTransitioningScale(index)
      })
      .animation({
        duration: 350, // ArkUI V2 ä¼˜åŒ–ï¼šç¨å¾®å»¶é•¿åŠ¨ç”»æ—¶é—´ï¼Œè®©è¿‡æ¸¡æ›´å¹³æ»‘
        curve: Curve.EaseOut, // ä½¿ç”¨ EaseOut è®©åŠ¨ç”»ç»“å°¾æ›´è‡ªç„¶
        iterations: 1,
        playMode: PlayMode.Normal,
        delay: 0 // ç¡®ä¿æ²¡æœ‰å»¶è¿Ÿï¼Œç«‹å³å¼€å§‹
      })
    } else {
      // ä¸æ¢è¡Œæ¨¡å¼ï¼šä½¿ç”¨Scrollç»„ä»¶é¿å…å­—ä½“å˜åŒ–æ—¶çš„é—ªåŠ¨
      Scroll() {
        Stack() {
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningHighlightLineTextSize()) // ä¿æŒå½“å‰è¡Œå­—ä½“å¤§å°ï¼Œé€šè¿‡ç¼©æ”¾å®ç°å¤§å°å˜åŒ–
            .fontColor(this.getTransitioningHighlightLineTextColor()) // ä½¿ç”¨åŠ¨æ€é¢œè‰²
            .fontWeight(this.getTransitioningHighlightLineFontWeight()) // ä¿æŒå½“å‰è¡Œå­—é‡
            .textAlign(this.getTextAlign())
            .maxLines(1) // å•è¡Œæ˜¾ç¤º
            .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
            .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
        }
        .alignContent(this.getAlignment())
      }
      .scrollable(ScrollDirection.Horizontal) // æ°´å¹³æ»šåŠ¨
      .scrollBar(BarState.Off) // éšè—æ»šåŠ¨æ¡
      .width(this.actualViewWidth)
      .height(this.getLineHeight())
      .position({
        x: this.linePaddingLeftRight,
        y: this.getTransitioningYPosition() // ä½¿ç”¨åŠ¨ç”»æ’å€¼ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getTransitioningScale(index),
        y: this.getTransitioningScale(index),
      })
      .animation({
        duration: 350, // ArkUI V2 ä¼˜åŒ–ï¼šç¨å¾®å»¶é•¿åŠ¨ç”»æ—¶é—´ï¼Œè®©è¿‡æ¸¡æ›´å¹³æ»‘
        curve: Curve.EaseOut, // ä½¿ç”¨ EaseOut è®©åŠ¨ç”»ç»“å°¾æ›´è‡ªç„¶
        iterations: 1,
        playMode: PlayMode.Normal,
        delay: 0 // ç¡®ä¿æ²¡æœ‰å»¶è¿Ÿï¼Œç«‹å³å¼€å§‹
      })
    }
  }

  /**
   * æ–°å½“å‰è¡Œè¿‡æ¸¡Builder - å¤„ç†ä»ä¸‹ä¸€è¡Œä½ç½®ç§»åŠ¨åˆ°ä¸­å¿ƒå¹¶å˜ä¸ºé«˜äº®æ ·å¼
   */
  @Builder
  NewCurrentLineTransitionBuilder(line: LyricsLineModel, index: number) {
    // æ ¹æ®enableLineWrapå†³å®šæ˜¾ç¤ºæ–¹å¼
    if (this.shouldEnableLineWrap()) {
      // æ¢è¡Œæ¨¡å¼ï¼šä½¿ç”¨Stackå¸ƒå±€
      Stack() {
        // èƒŒæ™¯æ–‡å­—ï¼ˆå¹³æ»‘è¿‡æ¸¡æ ·å¼ï¼‰
        Row() {
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize())
            .fontColor(this.getTransitioningTextColor())
            .fontWeight(this.getTransitioningFontWeight())
            .textAlign(this.getTextAlign())
            .width('100%')
            .maxLines(3) // æœ€å¤š3è¡Œ
            .textOverflow({ overflow: TextOverflow.Ellipsis })
            .animation({
              duration: 300, // æ ·å¼è¿‡æ¸¡åŠ¨ç”»
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })
        }
        .width('100%')
        .justifyContent(this.getRowJustifyContent())

        // é«˜äº®æ–‡å­—ï¼ˆæ¸è¿›æ˜¾ç¤ºï¼‰- å§‹ç»ˆæ˜¾ç¤ºï¼Œä½†åœ¨åŠ¨ç”»æœŸé—´ä½¿ç”¨ç›¸åŒçš„å­—ä½“å¤§å°
        Row() {
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—ä½“å¤§å°ï¼Œç¡®ä¿å®Œå…¨å¯¹é½
            .fontColor(this.currentLineHighlightedTextColor)
            .fontWeight(this.getTransitioningFontWeight()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—é‡
            .textAlign(this.getTextAlign())
            .width('100%')
            .maxLines(3) // æœ€å¤š3è¡Œ
            .textOverflow({ overflow: TextOverflow.Ellipsis })
            .animation({
              duration: 300, // æ ·å¼è¿‡æ¸¡åŠ¨ç”»ï¼Œä¸èƒŒæ™¯æ–‡å­—åŒæ­¥
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })
        }
        .width('100%')
        .justifyContent(this.getRowJustifyContent())
        .clip(true)
        .clipShape(new Rect({
          width: `${this.calculateLineProgress(line) * 100}%`,
          height: '100%'
        }))
        .opacity(this.styleTransitioning ? 1.0 : 0.0) // æ ·å¼è¿‡æ¸¡å¼€å§‹åæ‰æ˜¾ç¤ºé«˜äº®
        .animation({
          duration: 300, // é«˜äº®æ¸å…¥åŠ¨ç”»
          curve: Curve.EaseInOut,
          iterations: 1,
          playMode: PlayMode.Normal
        })
      }
      .width(this.actualViewWidth)
      .height(this.getDynamicLineHeight(line, this.currentLineTextSize))
      .alignContent(this.getAlignment())
      .position({
        x: this.linePaddingLeftRight,
        y: this.getNewCurrentYPosition() // ä½¿ç”¨æ–°å½“å‰è¡Œçš„ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getNewCurrentScale(),
        y: this.getNewCurrentScale()
      })
      .animation({
        duration: 400, // ä½ç½®å’Œç¼©æ”¾åŠ¨ç”»
        delay: this.getAnimationDelay(index),
        curve: Curve.EaseInOut,
        iterations: 1,
        playMode: PlayMode.Normal
      })
    } else {
      // ä¸æ¢è¡Œæ¨¡å¼ï¼šä½¿ç”¨Scrollç»„ä»¶é¿å…é—ªåŠ¨
      Scroll(this.textScroller) {
        Stack() {
          // èƒŒæ™¯æ–‡å­—ï¼ˆå•è¡Œæ˜¾ç¤ºï¼‰
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize())
            .fontColor(this.getTransitioningTextColor())
            .fontWeight(this.getTransitioningFontWeight())
            .textAlign(this.getTextAlign()) // å·¦å¯¹é½
            .maxLines(1) // å•è¡Œæ˜¾ç¤º
            .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
            .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
            .animation({
              duration: 300, // æ ·å¼è¿‡æ¸¡åŠ¨ç”»
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })

          // é«˜äº®æ–‡å­—ï¼ˆæ¸è¿›æ˜¾ç¤ºï¼Œå•è¡Œï¼‰- å§‹ç»ˆæ˜¾ç¤ºï¼Œä½†åœ¨åŠ¨ç”»æœŸé—´ä½¿ç”¨ç›¸åŒçš„å­—ä½“å¤§å°
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—ä½“å¤§å°ï¼Œç¡®ä¿å®Œå…¨å¯¹é½
            .fontColor(this.currentLineHighlightedTextColor)
            .fontWeight(this.getTransitioningFontWeight()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—é‡
            .textAlign(this.getTextAlign()) // å·¦å¯¹é½
            .maxLines(1) // å•è¡Œæ˜¾ç¤º
            .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
            .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
            .clip(true)
            .clipShape(new Rect({
              width: `${this.calculateLineProgress(line) * 100}%`,
              height: '100%'
            }))
            .opacity(this.styleTransitioning ? 1.0 : 0.0) // æ ·å¼è¿‡æ¸¡å¼€å§‹åæ‰æ˜¾ç¤ºé«˜äº®
            .animation({
              duration: 300, // é«˜äº®æ¸å…¥åŠ¨ç”»
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })
        }
        .alignContent(this.getAlignment())
      }
      .scrollable(ScrollDirection.Horizontal) // æ°´å¹³æ»šåŠ¨
      .scrollBar(BarState.Off) // éšè—æ»šåŠ¨æ¡
      .width(this.actualViewWidth)
      .height(this.getLineHeight())
      .position({
        x: this.linePaddingLeftRight,
        y: this.getNewCurrentYPosition() // ä½¿ç”¨æ–°å½“å‰è¡Œçš„ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getNewCurrentScale(),
        y: this.getNewCurrentScale()
      })
      .animation({
        duration: 400, // ä½ç½®å’Œç¼©æ”¾åŠ¨ç”»
        delay: this.getAnimationDelay(index),
        curve: Curve.EaseInOut,
        iterations: 1,
        playMode: PlayMode.Normal
      })
    }
  }

  /**
   * æ™®é€šè¡ŒBuilder
   */
  @Builder
  NormalLineBuilder(line: LyricsLineModel, index: number) {
    if (this.shouldEnableLineWrap()) {
      // æ¢è¡Œæ¨¡å¼ï¼šæ™®é€šè¡Œæ”¯æŒæ¢è¡Œ
      this.WrappedNormalLineBuilder(line, index);
    } else {
      // ä¸æ¢è¡Œæ¨¡å¼ï¼šæ™®é€šè¡Œå•è¡Œæ˜¾ç¤ºï¼Œä¸æ˜¾ç¤ºçœç•¥å·
      this.SingleLineNormalBuilder(line, index);
    }
  }

  /**
   * æ¢è¡Œæ™®é€šè¡ŒBuilder
   */
  @Builder
  WrappedNormalLineBuilder(line: LyricsLineModel, index: number) {
    Row() {
      Text(this.getLineText(line))
        .fontSize(this.textSize)
        .fontColor(this.getNormalLineColor(index))
        .fontWeight(FontWeight.Normal)
        .textAlign(this.getTextAlign())
        .width('100%')
        .maxLines(3) // æœ€å¤š3è¡Œ
        .textOverflow({ overflow: TextOverflow.Ellipsis })
    }
    .width(this.actualViewWidth)
    .height(this.getDynamicLineHeight(line, this.textSize))
    .justifyContent(this.getRowJustifyContent())
    .alignItems(VerticalAlign.Center)
    .position({ x: this.linePaddingLeftRight, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿ï¼Œä¸é«˜äº®è¡Œä¿æŒä¸€è‡´
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * å•è¡Œæ™®é€šè¡ŒBuilderï¼ˆä¸æ¢è¡Œï¼Œä¸æ˜¾ç¤ºçœç•¥å·ï¼‰
   */
  @Builder
  SingleLineNormalBuilder(line: LyricsLineModel, index: number) {
    Stack() {
      Text(this.getLineText(line))
        .fontSize(this.textSize)
        .fontColor(this.getNormalLineColor(index))
        .fontWeight(FontWeight.Normal)
        .textAlign(this.getTextAlign())
        .maxLines(1) // å•è¡Œæ˜¾ç¤º
        .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
        .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
    }
    .width(this.actualViewWidth)
    .height(this.getLineHeight())
    .alignContent(this.getAlignment())
    .clip(true) // è£å‰ªè¶…å‡ºéƒ¨åˆ†ï¼Œä¸æ˜¾ç¤ºçœç•¥å·
    .position({ x: this.linePaddingLeftRight, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿ï¼Œä¸é«˜äº®è¡Œä¿æŒä¸€è‡´
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * è®¡ç®—å½“å‰è¡Œçš„é«˜äº®è¿›åº¦ï¼ˆ0-1ä¹‹é—´ï¼‰
   * åŸºäºæ—¶é—´çš„ç²¾ç¡®è¿›åº¦è®¡ç®—ï¼Œé¿å…ä¸­æ–‡å­—ç¬¦è®¡ç®—åå¿«
   */
  private calculateLineProgress(line: LyricsLineModel): number {
    if (!line.tones || line.tones.length === 0) {
      return 0;
    }

    const lineStartTime = line.getStartTime();
    const lineEndTime = line.getEndTime();

    if (this.mCurrentTime < lineStartTime) {
      return 0;
    } else if (this.mCurrentTime >= lineEndTime) {
      return 1;
    }

    // åŸºäºæ—¶é—´çš„è¿›åº¦è®¡ç®—ï¼Œæ›´å‡†ç¡®åœ°åæ˜ æ’­æ”¾è¿›åº¦
    const lineDuration = lineEndTime - lineStartTime;
    const playedTime = this.mCurrentTime - lineStartTime;

    if (lineDuration <= 0) {
      return 1;
    }

    return Math.min(1, playedTime / lineDuration);
  }

  /**
   * è·å–å½“å‰è¡Œå­—ç¬¦é¢œè‰²ï¼ˆå®ç°é«˜äº®é€»è¾‘ï¼‰
   */
  private getCurrentLineCharColor(tone: Tone): string {
    // å½“å‰è¡Œçš„é«˜äº®é€»è¾‘ï¼šå”±è¿‡çš„éƒ¨åˆ†å…¨éƒ¨é«˜äº®
    if (this.mCurrentTime >= tone.begin) {
      return this.currentLineHighlightedTextColor; // é«˜äº®é¢œè‰²
    } else {
      return this.currentLineTextColor; // å½“å‰è¡Œæ­£å¸¸é¢œè‰²
    }
  }

  /**
   * è·å–æ™®é€šè¡Œé¢œè‰²
   */
  private getNormalLineColor(index: number): string {
    if (index < this.mIndexOfCurrentLine) {
      return this.previousLineTextColor; // å·²å”±è¿‡çš„è¡Œ
    } else {
      return this.upcomingLineTextColor; // æœªå”±çš„è¡Œ
    }
  }

  /**
   * è®¡ç®—è¡Œçš„é€æ˜åº¦ï¼ˆåŸºäºå¯è§æ€§å’Œè·ç¦»å½“å‰è¡Œçš„è¿œè¿‘ï¼‰
   */
  private getLineOpacity(index: number): number {
    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦åº”è¯¥æ¸²æŸ“è¯¥è¡Œ
    if (!this.shouldRenderLine(index)) {
      // ğŸ¯ å…³é”®æ—¥å¿—ï¼šç›‘æ§åŸå½“å‰è¡Œçš„é€æ˜åº¦å˜åŒ–
      if (Math.abs(Date.now() - this.animationKey) < 3000 && index === this.mIndexOfCurrentLine - 1) {
        LogUtils.d(`LyricsView: ğŸ‘» Line ${index} opacity set to 0.0 - shouldRenderLine returned false`);
      }
      return 0.0; // å¦‚æœå¼€å…³ç¦ç”¨äº†è¯¥è¡Œï¼Œå®Œå…¨é€æ˜
    }

    const isVisible = this.isLineVisible(index);

    // ğŸ¯ æ‹–æ‹½æ—¶ç§»é™¤ä¿åº•æœºåˆ¶ï¼Œå…è®¸æ‰€æœ‰è¡Œï¼ˆåŒ…æ‹¬åŸå½“å‰è¡Œï¼‰æ­£å¸¸æŒ‰ä½ç½®éšè—
    // è¿™æ ·å‘ä¸Šæ»šåŠ¨æ—¶å½“å‰è¡Œå¯ä»¥æ­£å¸¸ç§»å‡ºè§†å›¾é¡¶éƒ¨
    if (this.mDraggingInProgress) {
      // æ‹–æ‹½æ—¶ä¸ä½¿ç”¨ä¿åº•æœºåˆ¶ï¼Œå®Œå…¨ä¾èµ–isLineVisibleçš„è¾¹ç•Œåˆ¤æ–­
      // è¿™æ ·åŸå½“å‰è¡Œå¯ä»¥æ­£å¸¸ç§»å‡ºè§†å›¾èŒƒå›´
    }

    // å¦‚æœä¸å¯è§ï¼Œè¿”å›é€æ˜
    if (!isVisible) {
      // å·²ç»åœ¨ä¸Šé¢è®°å½•äº†æ—¥å¿—ï¼Œè¿™é‡Œç›´æ¥è¿”å›
      return 0.0;
    }

    // ğŸ¯ å¦‚æœç¦ç”¨äº†é€æ˜åº¦æ•ˆæœï¼Œæ‰€æœ‰å¯è§è¡Œéƒ½å®Œå…¨ä¸é€æ˜
    if (!this.enableOpacityEffect) {
      return 1.0;
    }

    // å¯è§çš„è¡Œæ ¹æ®è·ç¦»å½“å‰è¡Œçš„è¿œè¿‘è®¡ç®—é€æ˜åº¦
    // ğŸ¯ æ‹–æ‹½æ—¶ä½¿ç”¨è™šæ‹Ÿå½“å‰è¡Œç´¢å¼•è®¡ç®—è·ç¦»
    let currentIndex = this.mIndexOfCurrentLine;
    if (this.mDraggingInProgress && this.originalCurrentLineIndex >= 0) {
      const lyricsModel = this.mLyricMachine?.getLyricsModel();
      const virtualCurrentLineIndex = this.originalCurrentLineIndex - this.dragLineOffset;
      currentIndex = Math.max(0, Math.min(virtualCurrentLineIndex,
        (lyricsModel?.lines?.length || 1) - 1));
    }

    const distance = Math.abs(index - currentIndex);
    const maxVisibleLines = this.getMaxVisibleLines();
    const maxDistance = Math.floor(maxVisibleLines / 2);

    if (distance === 0) {
      return 1.0; // å½“å‰è¡Œå®Œå…¨ä¸é€æ˜
    } else if (distance <= maxDistance) {
      // ä½¿ç”¨æ›´å¹³æ»‘çš„é€æ˜åº¦æ¸å˜
      const fadeRatio = distance / maxDistance;
      const opacity = Math.max(0.2, 1.0 - (fadeRatio * 0.4)); // ä»1.0æ¸å˜åˆ°0.6
      return opacity;
    } else if (distance <= maxDistance + 1) {
      // è¾¹ç•Œè¡Œä½¿ç”¨å¾ˆä½çš„é€æ˜åº¦ï¼Œç¡®ä¿å¹³æ»‘è¿‡æ¸¡
      return 0.1;
    } else {
      return 0.0; // è¶…å‡ºèŒƒå›´çš„è¡Œå®Œå…¨é€æ˜
    }
  }

  /**
   * è®¡ç®—è¡Œçš„ç¼©æ”¾æ¯”ä¾‹
   */
  private getLineScale(index: number): number {
    if (index === this.mIndexOfCurrentLine) {
      return 1.1; // å½“å‰è¡Œç¨å¾®æ”¾å¤§ï¼Œçªå‡ºæ˜¾ç¤º
    } else {
      const distance = Math.abs(index - this.mIndexOfCurrentLine);
      // è·ç¦»å½“å‰è¡Œè¶Šè¿œï¼Œç¼©æ”¾è¶Šå°ï¼Œä½†ä¿æŒæœ€å°å€¼
      return Math.max(0.95, 1.0 - (distance * 0.03));
    }
  }

  /**
   * è·å–è¿‡æ¸¡è¡Œçš„Yä½ç½®ï¼ˆä½¿ç”¨åŠ¨ç”»æ’å€¼ï¼‰
   */
  private getTransitioningYPosition(): number {
    // åŸºäºæ ·å¼è¿‡æ¸¡çŠ¶æ€åˆ¤æ–­ï¼Œè€Œä¸æ˜¯æ—¶é—´
    if (!this.styleTransitioning) {
      return this.transitioningFromY; // ç¬¬ä¸€å¸§ï¼šèµ·å§‹ä½ç½®ï¼ˆä¸­å¿ƒä½ç½®ï¼‰
    } else {
      return this.transitioningToY; // åç»­å¸§ï¼šç›®æ ‡ä½ç½®ï¼Œè®©åŠ¨ç”»ç³»ç»Ÿå¤„ç†æ’å€¼
    }
  }

  /**
   * è·å–è¿‡æ¸¡è¡Œçš„å­—ä½“å¤§å°ï¼ˆä½¿ç”¨åŠ¨ç”»æ’å€¼ï¼‰
   */
  private getTransitioningHighlightLineTextSize(): number {
    // åŸºäºæ ·å¼è¿‡æ¸¡çŠ¶æ€åˆ¤æ–­ï¼Œè€Œä¸æ˜¯æ—¶é—´
    if (!this.styleTransitioning) {
      return this.currentLineTextSize; // ç¬¬ä¸€å¸§ï¼šä¿æŒé«˜äº®è¡Œå­—ä½“å¤§å°
    } else {
      return this.textSize; // åç»­å¸§ï¼šè¿‡æ¸¡åˆ°æ™®é€šè¡Œå­—ä½“å¤§å°
    }
  }

  /**
   * è·å–è¿‡æ¸¡è¡Œçš„å­—ä½“é¢œè‰²ï¼ˆä½¿ç”¨åŠ¨ç”»æ’å€¼ï¼‰
   */
  private getTransitioningHighlightLineTextColor(): string {
    // åŸºäºæ ·å¼è¿‡æ¸¡çŠ¶æ€åˆ¤æ–­ï¼Œè€Œä¸æ˜¯æ—¶é—´
    if (!this.styleTransitioning) {
      return this.currentLineHighlightedTextColor; // ç¬¬ä¸€å¸§ï¼šä¿æŒé«˜äº®è¡Œé¢œè‰²
    } else {
      return this.previousLineTextColor; // åç»­å¸§ï¼šè¿‡æ¸¡åˆ°æ™®é€šè¡Œé¢œè‰²
    }
  }

  /**
   * è·å–è¿‡æ¸¡è¡Œçš„å­—ä½“ç²—ç»†ï¼ˆä½¿ç”¨åŠ¨ç”»æ’å€¼ï¼‰
   */
  private getTransitioningHighlightLineFontWeight(): FontWeight {
    // åŸºäºæ ·å¼è¿‡æ¸¡çŠ¶æ€åˆ¤æ–­ï¼Œè€Œä¸æ˜¯æ—¶é—´
    if (!this.styleTransitioning) {
      return FontWeight.Bold; // ç¬¬ä¸€å¸§ï¼šä¿æŒé«˜äº®è¡Œå­—é‡
    } else {
      return FontWeight.Normal; // åç»­å¸§ï¼šè¿‡æ¸¡åˆ°æ™®é€šè¡Œå­—é‡
    }
  }

  /**
   * è·å–è¿‡æ¸¡è¡Œçš„ç¼©æ”¾æ¯”ä¾‹ï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰
   */
  private getTransitioningScale(index: number): number {
    // åŸºäºæ ·å¼è¿‡æ¸¡çŠ¶æ€åˆ¤æ–­ï¼Œè€Œä¸æ˜¯æ—¶é—´
    if (!this.styleTransitioning) {
      // ç¬¬ä¸€å¸§ï¼šä¿æŒé«˜äº®è¡Œç¼©æ”¾æ¯”ä¾‹
      return this.getLineScale(this.mIndexOfCurrentLine);
    } else {
      // åç»­å¸§ï¼šè¿‡æ¸¡åˆ°ç›®æ ‡è¡Œçš„ç¼©æ”¾æ¯”ä¾‹
      return this.getLineScale(index);
    }
  }

  /**
   * è·å–æ–°å½“å‰è¡Œçš„Yä½ç½®
   */
  private getNewCurrentYPosition(): number {
    // åœ¨åŠ¨ç”»åˆšå¼€å§‹æ—¶è¿”å›èµ·å§‹ä½ç½®ï¼Œç„¶åå¿«é€Ÿåˆ‡æ¢åˆ°ç›®æ ‡ä½ç½®è§¦å‘åŠ¨ç”»
    const currentTime = Date.now();
    const timeSinceAnimation = currentTime - this.animationKey;
    const isInStartPhase = timeSinceAnimation < 50;
    const position = isInStartPhase ? this.newCurrentFromY : this.newCurrentToY;

    return position;
  }

  /**
   * è·å–æ–°å½“å‰è¡Œçš„ç¼©æ”¾æ¯”ä¾‹
   */
  private getNewCurrentScale(): number {
    if (this.styleTransitioning) {
      return 1.1; // æ ·å¼è¿‡æ¸¡æ—¶ä½¿ç”¨å½“å‰è¡Œç¼©æ”¾
    } else {
      return 1.0; // ä½ç½®è¿‡æ¸¡æ—¶ä½¿ç”¨æ™®é€šè¡Œç¼©æ”¾
    }
  }

  /**
   * è·å–è¿‡æ¸¡ä¸­çš„å­—ä½“å¤§å°
   */
  private getTransitioningFontSize(): number {
    if (this.styleTransitioning) {
      return this.currentLineTextSize; // è¿‡æ¸¡åˆ°å½“å‰è¡Œå­—ä½“å¤§å°
    } else {
      return this.textSize; // å¼€å§‹æ—¶ä½¿ç”¨æ™®é€šè¡Œå­—ä½“å¤§å°
    }
  }

  /**
   * è·å–è¿‡æ¸¡ä¸­çš„æ–‡å­—é¢œè‰²
   */
  private getTransitioningTextColor(): string {
    if (this.styleTransitioning) {
      return this.currentLineTextColor; // è¿‡æ¸¡åˆ°å½“å‰è¡Œé¢œè‰²
    } else {
      return this.upcomingLineTextColor; // å¼€å§‹æ—¶ä½¿ç”¨æœªå”±è¡Œé¢œè‰²
    }
  }

  /**
   * è·å–è¿‡æ¸¡ä¸­çš„å­—ä½“ç²—ç»†
   */
  private getTransitioningFontWeight(): FontWeight {
    if (this.styleTransitioning) {
      return FontWeight.Bold; // è¿‡æ¸¡åˆ°å½“å‰è¡Œå­—é‡
    } else {
      return FontWeight.Normal; // å¼€å§‹æ—¶ä½¿ç”¨æ™®é€šè¡Œå­—é‡
    }
  }

  /**
   * æ ¹æ®æ­Œè¯è¡Œç´¢å¼•è·å–å¯¹åº”çš„å¼€å§‹æ—¶é—´
   * @param lineIndex æ­Œè¯è¡Œç´¢å¼•
   * @return å¯¹åº”çš„å¼€å§‹æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œå¦‚æœæ— æ•ˆåˆ™è¿”å›-1
   */
  private getLineStartTime(lineIndex: number): number {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines || lineIndex < 0 || lineIndex >= lyricsModel.lines.length) {
      return -1;
    }

    return lyricsModel.lines[lineIndex].getStartTime();
  }

  /**
   * å¤„ç†æ‹–æ‹½å¼€å§‹äº‹ä»¶
   * @param touchY åˆå§‹è§¦æ‘¸Yåæ ‡
   */
  private handleDragStart(touchY: number): void {
    if (!this.enableDragging) {
      return;
    }

    this.mDraggingInProgress = true;
    this.initialTouchY = touchY;
    this.dragLineOffset = 0;
    this.originalCurrentLineIndex = this.mIndexOfCurrentLine; // è®°å½•æ‹–æ‹½å¼€å§‹æ—¶çš„å½“å‰è¡Œ

    // é€šè¿‡EventBusé€šçŸ¥æ‹–æ‹½å¼€å§‹
    this.eventBus.emit(LyricsEvents.DRAG_START);
  }

  /**
   * å¤„ç†æ‹–æ‹½ç§»åŠ¨äº‹ä»¶
   * @param touchY å½“å‰è§¦æ‘¸Yåæ ‡
   */
  private handleDragMove(touchY: number): void {
    if (!this.enableDragging || !this.mDraggingInProgress) {
      return;
    }

    // è®¡ç®—Yè½´ç§»åŠ¨è·ç¦»
    const deltaY = touchY - this.initialTouchY;

    // æ ¹æ®Yè½´ç§»åŠ¨è·ç¦»è®¡ç®—æ­Œè¯è¡Œåç§»é‡
    // ğŸ¯ ä½¿ç”¨åŠ¨æ€è¡Œé«˜ç¡®ä¿æ‹–æ‹½è®¡ç®—ä¸æ¸²æŸ“ä¸€è‡´
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    let lineHeight = this.getLineHeight(); // é»˜è®¤å€¼

    if (lyricsModel && lyricsModel.lines && this.originalCurrentLineIndex >= 0 &&
      this.originalCurrentLineIndex < lyricsModel.lines.length) {
      const currentLine = lyricsModel.lines[this.originalCurrentLineIndex];
      lineHeight = currentLine ?
      this.getDynamicLineHeight(currentLine, this.currentLineTextSize) :
      this.getLineHeight();
    }

    const rawLineOffset = Math.round(deltaY / lineHeight);

    // è®¡ç®—æ‹–æ‹½è¾¹ç•Œé™åˆ¶
    if (lyricsModel && lyricsModel.lines) {
      // è®¡ç®—æ›´ä¿å®ˆçš„è¾¹ç•Œé™åˆ¶
      const totalLines = lyricsModel.lines.length;

      // å‘ä¸Šæ‹–æ‹½é™åˆ¶ï¼šä¸èƒ½è¶…è¿‡ç¬¬ä¸€è¡Œ
      const maxUpwardOffset = this.originalCurrentLineIndex;

      // å‘ä¸‹æ‹–æ‹½é™åˆ¶ï¼šä¸èƒ½è¶…è¿‡æœ€åä¸€è¡Œ
      const maxDownwardOffset = totalLines - 1 - this.originalCurrentLineIndex;

      // é™åˆ¶æ‹–æ‹½åç§»é‡åœ¨å®‰å…¨èŒƒå›´å†…
      this.dragLineOffset = Math.max(-maxDownwardOffset, Math.min(maxUpwardOffset, rawLineOffset));

      // ğŸ¯ æ‹–æ‹½è°ƒè¯•æ—¥å¿—ï¼šæ˜¾ç¤ºè™šæ‹Ÿå½“å‰è¡Œå˜åŒ–ï¼Œå®ç°æ»šåŠ¨åˆ—è¡¨æ•ˆæœ
      const virtualCurrentLineIndex = this.originalCurrentLineIndex - this.dragLineOffset;
      const clampedVirtualIndex = Math.max(0, Math.min(virtualCurrentLineIndex, totalLines - 1));
    } else {
      this.dragLineOffset = 0;
    }
  }

  /**
   * å¤„ç†æ‹–æ‹½ç»“æŸäº‹ä»¶
   * @param touchY æœ€ç»ˆè§¦æ‘¸ç‚¹çš„Yåæ ‡
   */
  private handleDragEnd(touchY: number): void {
    if (!this.enableDragging) {
      return;
    }

    this.mDraggingInProgress = false;

    // è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡è¡Œç´¢å¼•
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (lyricsModel && lyricsModel.lines) {
      const finalLineIndex = this.originalCurrentLineIndex - this.dragLineOffset;
      const clampedIndex = Math.max(0, Math.min(finalLineIndex, lyricsModel.lines.length - 1));
      const startTime = this.getLineStartTime(clampedIndex);

      if (startTime >= 0) {
        // é€šè¿‡EventBusé€šçŸ¥æœ€ç»ˆæ‹–æ‹½ä½ç½®
        this.eventBus.emit(LyricsEvents.DRAG_END, startTime);
      }
    }

    // é‡ç½®æ‹–æ‹½çŠ¶æ€
    this.initialTouchY = 0;
    this.dragLineOffset = 0;
    this.originalCurrentLineIndex = -1;
  }

  /**
   * Renders the prelude end position indicator
   */
  @Builder
  PreludeIndicatorBuilder() {
    if (this.enablePreludeEndPositionIndicator && this.lyricsModel &&
      this.getPreludeCountDown() > 0) {
      Row() {
        // Indicator 1
        Circle({
          width: this.preludeEndPositionIndicatorRadius * 2,
          height: this.preludeEndPositionIndicatorRadius * 2
        })
          .fill(this.preludeEndPositionIndicatorColor)

        if (this.getPreludeCountDown() >= 2) {
          // Indicator 2
          Circle({
            width: this.preludeEndPositionIndicatorRadius * 2,
            height: this.preludeEndPositionIndicatorRadius * 2
          })
            .fill(this.preludeEndPositionIndicatorColor)
            .margin({ left: this.preludeEndPositionIndicatorRadius * 2 })
        }

        if (this.getPreludeCountDown() >= 3) {
          // Indicator 3 (with blinking effect)
          Circle({
            width: this.preludeEndPositionIndicatorRadius * 2,
            height: this.preludeEndPositionIndicatorRadius * 2
          })
            .fill(this.preludeEndPositionIndicatorColor)
            .margin({ left: this.preludeEndPositionIndicatorRadius * 2 })
            .opacity((this.getPreludeCountDown() % 2 === 1 || this.mCurrentTime < 2000) ? 1 : 0)
        }
      }
      .width('100%')
      .justifyContent(this.getRowJustifyContent())
      .margin({ top: this.preludeEndPositionIndicatorPaddingTop })
    }
  }

  build() {
    Column() {
      // Prelude indicator
      this.PreludeIndicatorBuilder()

      if (this.uninitializedOrNoLyrics()) {
        this.NoLyricsBuilder()
      } else {
        // ä½¿ç”¨ Stack æ¥æ”¯æŒç»å¯¹å®šä½
        Stack() {
          if (this.lyricsLines.length > 0) {
            ForEach(this.lyricsLines, (line: LyricsLineModel, index: number) => {
              // æ ¹æ®å¼€å…³å†³å®šæ˜¯å¦ç»˜åˆ¶è¯¥è¡Œ
              if (this.shouldRenderLine(index)) {
                this.EnhancedLyricsLineBuilder(line, index)
              }
            })
          }
        }
        .width('100%')
        .height('100%')
        .alignContent(Alignment.TopStart) // ä»é¡¶éƒ¨å¼€å§‹å®šä½
        .clip(true) // ğŸ¯ è£å‰ªè¶…å‡ºè¾¹ç•Œçš„æ­Œè¯å†…å®¹ï¼Œé˜²æ­¢æ˜¾ç¤ºåœ¨è§†å›¾å¤–
      }
    }
    .width('100%')
    .height('90%')
    .backgroundColor(this.viewBackgroundColor)
    .margin({ top: this.paddingTop })
    .onTouch((event: TouchEvent) => {
      if (!this.enableDragging) {
        return false;
      }

      switch (event.type) {
        case TouchType.Down:
          this.handleDragStart(event.touches[0].y);
          return true;
        case TouchType.Move:
          this.handleDragMove(event.touches[0].y);
          return true;
        case TouchType.Up:
        case TouchType.Cancel:
          this.handleDragEnd(event.touches[0].y);
          return true;
        default:
          return false;
      }
    })
    .onAreaChange((oldValue: Area, newValue: Area) => {
      // åŠ¨æ€è·å–ç»„ä»¶å®é™…å°ºå¯¸
      if (newValue.height && typeof newValue.height === 'number') {
        this.actualViewHeight = newValue.height;
        LogUtils.d(`LyricsView: Component height measured: ${this.actualViewHeight}`);
        // é«˜åº¦å˜åŒ–åï¼Œä½ç½®ä¼šè‡ªåŠ¨é‡æ–°è®¡ç®—ï¼Œä¸éœ€è¦æ‰‹åŠ¨æ»šåŠ¨
      }
      if (newValue.width && typeof newValue.width === 'number') {
        this.actualViewWidth = newValue.width - this.linePaddingLeftRight * 2;
        LogUtils.d(`LyricsView: Component width measured: ${this.actualViewWidth}`);
      }
    })
    .onAppear(() => {
      LogUtils.d('LyricsView: Component appeared, setting up event listeners');
      this.setupEventListeners();
    })
    .onDisAppear(() => {
      LogUtils.d('LyricsView: Component disappearing, cleaning up');
      this.removeEventListeners();
      this.resetCompletely(); // å®Œå…¨æ¸…ç†
    })
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
   */
  private setupEventListeners(): void {
    LogUtils.d('LyricsView: Setting up event listeners');

    // åˆå§‹åŒ–LyricMachine
    this.initLyricMachine();

    // ç›‘å¬æ­Œè¯æ•°æ®è®¾ç½®äº‹ä»¶
    const setLyricDataHandler = (lyricModel: LyricModel) => {
      if (this.mLyricMachine) {
        this.mLyricMachine.prepare(lyricModel);

        // ç«‹å³åŒæ­¥æ›´æ–°å“åº”å¼çŠ¶æ€
        const currentModel = this.mLyricMachine.getLyricsModel();
        this.lyricsModel = currentModel;
        this.lyricsLines = currentModel?.lines || [];

        this.forceCheckLineWrap();
        LogUtils.d(`LyricsView: Lyric data set successfully, model: ${!!this.lyricsModel}, lines: ${this.lyricsLines.length}`);
      } else {
        LogUtils.e('LyricsView: mLyricMachine is null when receiving SET_LYRIC_DATA event');
      }
    };
    this.eventBus.on(LyricsEvents.SET_LYRIC_DATA, setLyricDataHandler);

    // ç›‘å¬è¿›åº¦æ›´æ–°äº‹ä»¶
    this.eventBus.on(LyricsEvents.SET_PROGRESS, (progress: number) => {
      if (this.mLyricMachine) {
        this.mLyricMachine.setProgress(progress);
      }
    });

    // ç›‘å¬é‡ç½®äº‹ä»¶
    this.eventBus.on(LyricsEvents.RESET, () => {
      LogUtils.d('LyricsView: Received RESET event');
      if (this.mLyricMachine) {
        this.mLyricMachine.reset();
      }
    });

    // ç›‘å¬åˆ·æ–°UIäº‹ä»¶
    this.eventBus.on(LyricsEvents.REQUEST_REFRESH, () => {
      LogUtils.d('LyricsView: Received REQUEST_REFRESH event');
      this.requestRefreshUi();
    });
  }

  /**
   * ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
   */
  private removeEventListeners(): void {
    LogUtils.d('LyricsView: Removing event listeners');
    // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„ç§»é™¤é€»è¾‘ï¼Œä½†ç”±äºEventBusæ˜¯å•ä¾‹ï¼Œ
    // æˆ‘ä»¬å¯èƒ½éœ€è¦ä¿å­˜å›è°ƒå‡½æ•°çš„å¼•ç”¨æ¥æ­£ç¡®ç§»é™¤
  }

  /**
   * åˆå§‹åŒ–LyricMachine
   */
  private initLyricMachine(): void {
    // åˆ›å»ºLyricMachineå¹¶å‡†å¤‡æ•°æ®
    if (!this.mLyricMachine) {
      LogUtils.d('LyricsView: Creating new LyricMachine');

      // åˆ›å»ºä¸€ä¸ªç®€å•çš„ç›‘å¬å™¨å®ç°
      class LyricListenerImpl implements OnLyricListener {
        private lyricsView: LyricsView;

        constructor(lyricsView: LyricsView) {
          this.lyricsView = lyricsView;
        }

        resetUi(): void {
          this.lyricsView.reset();
        }

        requestRefreshUi(): void {
          this.lyricsView.requestRefreshUi();
        }
      }

      const listener = new LyricListenerImpl(this);
      this.mLyricMachine = new LyricMachine(listener);
      LogUtils.d(`LyricsView: LyricMachine created successfully, initial ready state: ${this.mLyricMachine.isReady()}`);
    } else {
      LogUtils.d('LyricsView: LyricMachine already exists');
    }
  }
}
