import { LyricType } from '../constants/LyricType';
import { LyricMachine, OnLyricListener } from '../internal/LyricMachine';
import { LyricModel } from '../model/LyricModel';
import { LyricsLineModel, Tone } from '../model/LyricsLineModel';
import { EventBus, LyricsEvents } from '../utils/EventBus';
import { LogUtils } from '../utils/LogUtils';

/**
 * ç‰©ç†æ˜¾ç¤ºè¡Œæ¥å£
 * è¡¨ç¤ºä¸€ä¸ªé€»è¾‘æ­Œè¯è¡Œåˆ†å‰²åçš„ç‰©ç†æ˜¾ç¤ºè¡Œ
 */
interface DisplayLine {
  text: string;
  tones: Tone[];
  startTime: number;
  endTime: number;
}


/**
 * A custom component for displaying karaoke lyrics with various visual effects.
 * Supports features like highlighting current line, scrolling animations,
 * line wrapping, and touch interactions for seeking.
 */
@Component
export struct LyricsView {
  // Core properties
  /** The lyrics state machine managing lyrics progression */
  @State private mLyricMachine: LyricMachine | null = null;
  /** Index of the currently displayed lyrics line */
  @State private mIndexOfCurrentLine: number = -1;
  /** Current timestamp in the lyrics playback */
  @State private mCurrentTime: number = 0;
  // Visual configuration properties (corresponding to attrs.xml)
  /** Text size for normal lyrics lines */
  @Prop textSize: number = 16;
  /** Text size for current line */
  @Prop currentLineTextSize: number = 20;
  /** Text color for current line's normal text */
  @Prop currentLineTextColor: string = '#FFFFFF';
  /** Text color for current line's highlighted portion */
  @Prop currentLineHighlightedTextColor: string = '#FF6B35';
  /** Text color for previous lyrics lines */
  @Prop previousLineTextColor: string = '#999999';
  /** Text color for upcoming lyrics lines */
  @Prop upcomingLineTextColor: string = '#999999';
  /** Vertical spacing between lyrics lines */
  @Prop lineSpacing: number = 12;
  /** Top padding for the entire lyrics view */
  @Prop paddingTop: number = 5;
  /** Text to display when no lyrics are available */
  @Prop labelWhenNoLyrics: string = 'æš‚æ— æ­Œè¯';
  /** Whether to enable automatic line wrapping for long lyrics */
  @Prop enableLineWrap: boolean = false;
  /** Whether dragging is enabled */
  @Prop enableDragging: boolean = true;
  /** Whether to show lyrics lines before the current line */
  @Prop enablePreviousLines: boolean = true;
  /** Whether to show lyrics lines after the current line */
  @Prop enableUpcomingLines: boolean = true;
  /** Whether to show the prelude end position indicator */
  @Prop enablePreludeEndPositionIndicator: boolean = true;
  /** Top padding for the prelude end position indicator */
  @Prop preludeEndPositionIndicatorPaddingTop: number = 3;
  /** Radius of the prelude end position indicator dots */
  @Prop preludeEndPositionIndicatorRadius: number = 4;
  /** Color of the prelude end position indicator */
  @Prop preludeEndPositionIndicatorColor: string = '#FF6B35';
  /** Horizontal alignment of lyrics text (0=center, 1=left, 2=right) */
  @Prop textGravity: number = 0;
  // Internal state
  @State private mDraggingInProgress: boolean = false;
  @State private mOffset: number = 0;
  @State private mForceUpdateUi: number = 1; // UPDATE_UI_TYPE_NORMAL
  @State private mCurrentLineTranslateX: number = 0;
  @State private mWidthRatio: number = 1.0;
  @State private targetIndex: number = 0;
  // æ¨ªå‘æ»šåŠ¨ç›¸å…³çŠ¶æ€
  @State private mLastRightOfRectClip: number = 0; // ä¸Šæ¬¡é«˜äº®åŒºåŸŸçš„å³è¾¹ç•Œ
  @State private mRectClipWidth: number = 0; // å½“å‰é«˜äº®åŒºåŸŸå®½åº¦
  // Actual component dimensions measured dynamically
  @State private actualViewHeight: number = 400; // é»˜è®¤å€¼ï¼Œä¼šè¢«å®é™…æµ‹é‡å€¼è¦†ç›–
  @State private actualViewWidth: number = 300; // é»˜è®¤å€¼ï¼Œä¼šè¢«å®é™…æµ‹é‡å€¼è¦†ç›–
  // æ‹–æ‹½ç›¸å…³çŠ¶æ€
  @State private dragOffset: number = 0; // æ‹–æ‹½åç§»é‡
  @State private initialTouchY: number = 0; // åˆå§‹è§¦æ‘¸Yåæ ‡
  @State private currentTouchY: number = 0; // å½“å‰è§¦æ‘¸Yåæ ‡
  @State private dragLineOffset: number = 0; // æ‹–æ‹½æ—¶çš„æ­Œè¯è¡Œåç§»é‡
  @State private originalCurrentLineIndex: number = -1; // æ‹–æ‹½å¼€å§‹æ—¶çš„åŸå§‹å½“å‰è¡Œç´¢å¼•
  // åŠ¨ç”»çŠ¶æ€ç®¡ç†
  @State private isAnimating: boolean = false;
  @State private animationKey: number = 0; // ç”¨äºå¼ºåˆ¶é‡æ–°æ¸²æŸ“åŠ¨ç”»
  @State private previousLineIndex: number = -1; // è®°å½•ä¸Šä¸€è¡Œç´¢å¼•ï¼Œç”¨äºåŠ¨ç”»åˆ¤æ–­
  @State private transitioningFromIndex: number = -1; // æ­£åœ¨è¿‡æ¸¡çš„åŸå½“å‰è¡Œç´¢å¼•
  @State private transitioningFromY: number = 0; // è¿‡æ¸¡è¡Œçš„èµ·å§‹Yä½ç½®
  @State private transitioningToY: number = 0; // è¿‡æ¸¡è¡Œçš„ç›®æ ‡Yä½ç½®
  @State private newCurrentTransitioning: boolean = false; // æ–°å½“å‰è¡Œæ˜¯å¦æ­£åœ¨è¿‡æ¸¡
  @State private newCurrentFromY: number = 0; // æ–°å½“å‰è¡Œçš„èµ·å§‹Yä½ç½®
  @State private newCurrentToY: number = 0; // æ–°å½“å‰è¡Œçš„ç›®æ ‡Yä½ç½®
  @State private styleTransitioning: boolean = false; // æ ·å¼æ˜¯å¦æ­£åœ¨è¿‡æ¸¡
  // æ–‡æœ¬æ»šåŠ¨ç›¸å…³çŠ¶æ€
  @State private textScrollOffset: number = 0; // å½“å‰æ–‡æœ¬æ»šåŠ¨åç§»
  @State private isTextScrolling: boolean = false; // æ˜¯å¦æ­£åœ¨æ»šåŠ¨æ–‡æœ¬
  @State private textScrollTimer: number = -1; // æ–‡æœ¬æ»šåŠ¨å®šæ—¶å™¨
  // Scroll controller for auto-scrolling
  private scroller: Scroller = new Scroller();
  // Text scroll controller for horizontal scrolling
  private textScroller: Scroller = new Scroller();
  // å½“å‰è¡Œçš„æ»šåŠ¨åç§»çŠ¶æ€ï¼ˆç”¨äºè°ƒè¯•æ—¥å¿—ï¼‰
  @State private currentLineScrollOffset: number = 0;
  // Event bus instance for global communication
  private eventBus: EventBus = EventBus.getInstance();
  // Update UI type constants
  private static readonly UPDATE_UI_TYPE_NO_NEED: number = 0;
  private static readonly UPDATE_UI_TYPE_NORMAL: number = 1;
  private static readonly UPDATE_UI_TYPE_WITH_ANIMATION: number = 2;

  /**
   * Requests a refresh of the UI.
   * Updates the progress and triggers a redraw if necessary.
   */
  requestRefreshUi(): void {
    if (this.mLyricMachine) {
      this.updateByProgress(this.mLyricMachine.getCurrentLyricProgress());
    }
  }

  /**
   * Resets the view to its initial state.
   * Clears all loaded lyrics and internal state.
   */
  reset(): void {
    this.resetInternal();
  }

  /**
   * å®Œå…¨é‡ç½®ï¼ŒåŒ…æ‹¬æ¸…ç† LyricMachine å¼•ç”¨
   * ä»…åœ¨ç»„ä»¶é”€æ¯æˆ–éœ€è¦å®Œå…¨æ¸…ç†æ—¶è°ƒç”¨
   */
  resetCompletely(): void {
    this.mLyricMachine = null;
    this.resetInternal();
  }

  /**
   * Checks if the lyrics view is uninitialized or has no lyrics data.
   * @return true if lyrics are not available or not initialized
   */
  private uninitializedOrNoLyrics(): boolean {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    return !this.mLyricMachine || !lyricsModel ||
      !lyricsModel.lines || lyricsModel.lines.length === 0;
  }

  /**
   * Updates the view based on the current timestamp.
   * Handles line transitions and triggers animations when necessary.
   * @param timestamp Current playback position in milliseconds
   */
  private updateByProgress(timestamp: number): void {
    this.mCurrentTime = timestamp;
    const lyricsModel = this.mLyricMachine?.getLyricsModel();

    if (this.refreshNoLyrics()) {
      LogUtils.d('LyricsView: No lyrics available, showing no lyrics message');
      return;
    }

    const line = this.quickSearchLineByTimestamp(this.mCurrentTime);

    if (line < 0 || !lyricsModel || line >= lyricsModel.lines.length) {
      LogUtils.d('LyricsView: Invalid line index, no UI update needed');
      this.mForceUpdateUi = LyricsView.UPDATE_UI_TYPE_NO_NEED;
      return;
    }

    if (line !== this.mIndexOfCurrentLine) {
      LogUtils.d(`LyricsView: Line changed from ${this.mIndexOfCurrentLine} to ${line}`);

      // åœæ­¢ä¹‹å‰è¡Œçš„æ–‡æœ¬æ»šåŠ¨
      this.stopTextScrollAnimation();

      // è§¦å‘è¡Œå˜åŒ–åŠ¨ç”»
      this.triggerLineChangeAnimation(this.mIndexOfCurrentLine, line);

      this.previousLineIndex = this.mIndexOfCurrentLine;
      this.mIndexOfCurrentLine = line;
      this.mForceUpdateUi = LyricsView.UPDATE_UI_TYPE_NORMAL | LyricsView.UPDATE_UI_TYPE_WITH_ANIMATION;

      // å¯åŠ¨æ–°å½“å‰è¡Œçš„æ–‡æœ¬æ»šåŠ¨
      const lyricsModel = this.mLyricMachine?.getLyricsModel();
      if (lyricsModel && lyricsModel.lines && line >= 0 && line < lyricsModel.lines.length) {
        this.startTextScrollAnimation(lyricsModel.lines[line]);
      }

      LogUtils.d(`LyricsView: Current line updated to ${line}, animation triggered`);
    }

    // æ¨ªå‘æ»šåŠ¨ç°åœ¨ç”±startTextScrollAnimationçš„å®šæ—¶å™¨å¤„ç†ï¼Œæ— éœ€åœ¨è¿™é‡Œé¢å¤–æ£€æŸ¥
  }

  /**
   * Refreshes the "No Lyrics" display state.
   * @return true if no lyrics are available and refresh was performed
   */
  private refreshNoLyrics(): boolean {
    return this.uninitializedOrNoLyrics();
  }

  /**
   * Performs binary search to find the lyrics line that should be displayed at the given timestamp.
   * @param time Current timestamp in milliseconds
   * @return Index of the lyrics line to display
   */
  private quickSearchLineByTimestamp(time: number): number {
    if (this.uninitializedOrNoLyrics()) {
      return 0;
    }

    let left = 0;
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel) {
      return 0;
    }
    let right = lyricsModel.lines.length - 1;

    while (left <= right) {
      const middle = Math.floor((left + right) / 2);
      const middleTime = lyricsModel.lines[middle].getStartTime();

      if (time < middleTime) {
        right = middle - 1;
      } else {
        if (middle + 1 >= lyricsModel.lines.length ||
          time < lyricsModel.lines[middle + 1].getStartTime()) {
          return middle;
        }
        left = middle + 1;
      }
    }

    return 0;
  }

  /**
   * Resets all internal state variables to their default values.
   */
  private resetInternal(): void {
    this.mForceUpdateUi = LyricsView.UPDATE_UI_TYPE_NORMAL;
    this.mCurrentTime = 0;
    this.mOffset = 0;
    this.targetIndex = 0;
    this.mCurrentLineTranslateX = 0;
    this.mLastRightOfRectClip = 0;
    this.mRectClipWidth = 0;

    // åœæ­¢æ–‡æœ¬æ»šåŠ¨åŠ¨ç”»
    this.stopTextScrollAnimation();

    LogUtils.d(`LyricsView: ğŸ”„ resetInternal called - currentLineScrollOffset reset to: ${this.currentLineScrollOffset}`);
  }

  /**
   * Force check line wrap based on lyric type
   */
  private forceCheckLineWrap(): void {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines || lyricsModel.lines.length === 0) {
      return;
    }
    if (lyricsModel.type === LyricType.LRC) {
      this.enableLineWrap = true;
    }
  }

  /**
   * Renders the no lyrics state
   */
  @Builder
  NoLyricsBuilder() {
    Column() {
      Text(this.labelWhenNoLyrics)
        .fontSize(this.currentLineTextSize)
        .fontColor(this.currentLineHighlightedTextColor)
        .textAlign(this.getTextAlign())
    }
    .width('100%')
    .height('100%')
    .justifyContent(this.getRowJustifyContent())
  }

  /**
   * Gets the complete text of a lyrics line
   */
  private getLineText(line: LyricsLineModel): string {
    if (line.tones && line.tones.length > 0) {
      return line.tones.map(tone => tone.word).join('');
    }
    return '';
  }

  /**
   * Gets the index of a lyrics line
   */
  private getLineIndex(line: LyricsLineModel): number {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines) {
      return -1;
    }
    return lyricsModel.lines.indexOf(line);
  }

  /**
   * Gets text alignment based on textGravity property
   */
  private getTextAlign(): TextAlign {
    switch (this.textGravity) {
      case 1:
        return TextAlign.Start; // left
      case 2:
        return TextAlign.End; // right
      default:
        return TextAlign.Center; // center
    }
  }

  /**
   * æ ¹æ®textGravityè·å–Rowçš„å¯¹é½æ–¹å¼
   */
  private getRowJustifyContent(): FlexAlign {
    switch (this.textGravity) {
      case 1:
        return FlexAlign.Start; // left
      case 2:
        return FlexAlign.End; // right
      default:
        return FlexAlign.Center; // center
    }
  }

  /**
   * æ ¹æ®textGravityè·å–Alignmentå¯¹é½æ–¹å¼
   */
  private getAlignment(): Alignment {
    switch (this.textGravity) {
      case 1:
        return Alignment.Start; // left
      case 2:
        return Alignment.End; // right
      default:
        return Alignment.Center; // center
    }
  }

  /**
   * Gets the countdown value for prelude indicator
   */
  private getPreludeCountDown(): number {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel) {
      return 0;
    }
    return Math.ceil((lyricsModel.preludeEndPosition - this.mCurrentTime) / 1000);
  }

  /**
   * è§¦å‘è¡Œå˜åŒ–åŠ¨ç”»
   */
  private triggerLineChangeAnimation(fromLine: number, toLine: number): void {
    if (fromLine === toLine) {
      return;
    }

    this.isAnimating = true;
    this.transitioningFromIndex = fromLine; // è®°å½•åŸå½“å‰è¡Œ
    this.newCurrentTransitioning = true; // æ–°å½“å‰è¡Œå¼€å§‹è¿‡æ¸¡
    this.styleTransitioning = false; // æ ·å¼è¿‡æ¸¡ç¨åå¼€å§‹

    LogUtils.d(`LyricsView: ğŸ¬ Animation state set - isAnimating: ${this.isAnimating}, transitioningFromIndex: ${this.transitioningFromIndex}, newCurrentTransitioning: ${this.newCurrentTransitioning}, mIndexOfCurrentLine: ${this.mIndexOfCurrentLine}`);

    // è®°å½•ç»„ä»¶é€‰æ‹©é€»è¾‘
    LogUtils.d(`LyricsView: ğŸ­ Component selection - Line ${this.transitioningFromIndex} will use TransitioningHighlightLineBuilder`);
    LogUtils.d(`LyricsView: ğŸ­ Component selection - Line ${this.mIndexOfCurrentLine} will use NewCurrentLineTransitionBuilder (newCurrentTransitioning: ${this.newCurrentTransitioning})`);

    const lineHeight = this.getLineHeight();
    const centerY = (this.actualViewHeight / 2) - (lineHeight / 2);

    // === åŸå½“å‰è¡Œè¿‡æ¸¡è®¾ç½® ===
    // åŸå½“å‰è¡Œä»ä¸­å¿ƒä½ç½®å¼€å§‹
    this.transitioningFromY = centerY;

    // è®¡ç®—åŸå½“å‰è¡Œçš„ç›®æ ‡ä½ç½®
    // åŸå½“å‰è¡Œ(fromLine)åœ¨æ–°å¸ƒå±€ä¸­åº”è¯¥ä½äºä¸Šä¸€è¡Œä½ç½®
    // ä¸Šä¸€è¡Œä½ç½® = ä¸­å¿ƒä½ç½® - ä¸€ä¸ªè¡Œé«˜
    const oldTargetY = centerY - lineHeight;

    LogUtils.d(`LyricsView: ğŸ¬ Animation START - fromLine: ${fromLine}, toLine: ${toLine}, centerY: ${centerY}, lineHeight: ${lineHeight}, oldTargetY: ${oldTargetY}`);

    // è®¾ç½®èµ·å§‹ä½ç½®
    this.transitioningFromY = centerY; // è¿‡æ¸¡è¡Œèµ·å§‹ä½ç½®ï¼šä¸­å¿ƒ
    this.newCurrentFromY = centerY + lineHeight; // æ–°å½“å‰è¡Œèµ·å§‹ä½ç½®ï¼šä¸‹ä¸€è¡Œ

    // è®¾ç½®ç›®æ ‡ä½ç½®
    this.transitioningToY = oldTargetY; // è¿‡æ¸¡è¡Œç›®æ ‡ä½ç½®ï¼šä¸Šä¸€è¡Œ
    this.newCurrentToY = centerY; // æ–°å½“å‰è¡Œç›®æ ‡ä½ç½®ï¼šä¸­å¿ƒ

    this.animationKey = Date.now(); // æ›´æ–°åŠ¨ç”»é”®å€¼ï¼Œå¼ºåˆ¶é‡æ–°æ¸²æŸ“

    LogUtils.d(`LyricsView: ğŸ“ Position setup - Transitioning: ${this.transitioningFromY} -> ${this.transitioningToY} (diff: ${this.transitioningToY -
    this.transitioningFromY})`);
    LogUtils.d(`LyricsView: ğŸ“ Position setup - NewCurrent: ${this.newCurrentFromY} -> ${this.newCurrentToY} (diff: ${this.newCurrentToY -
    this.newCurrentFromY})`);
    LogUtils.d(`LyricsView: â° Animation key set to: ${this.animationKey}`);

    // ä½ç½®åŠ¨ç”»å¼€å§‹åå¾ˆå¿«å¼€å§‹æ ·å¼è¿‡æ¸¡ï¼Œåˆ›é€ é‡å æ•ˆæœ
    setTimeout(() => {
      if (this.isAnimating) {
        this.styleTransitioning = true; // å¼€å§‹æ ·å¼è¿‡æ¸¡
      }
    }, 150); // ä½ç½®åŠ¨ç”»å¼€å§‹150msåå¼€å§‹æ ·å¼è¿‡æ¸¡

    // åŠ¨ç”»å®Œæˆåæ¸…é™¤çŠ¶æ€
    setTimeout(() => {
      LogUtils.d(`LyricsView: ğŸ Animation END - Clearing animation states`);
      this.isAnimating = false;
      this.transitioningFromIndex = -1; // æ¸…é™¤è¿‡æ¸¡çŠ¶æ€
      this.newCurrentTransitioning = false; // æ¸…é™¤æ–°å½“å‰è¡Œè¿‡æ¸¡çŠ¶æ€
      this.styleTransitioning = false; // æ¸…é™¤æ ·å¼è¿‡æ¸¡çŠ¶æ€
      LogUtils.d(`LyricsView: ğŸ Animation states cleared - Line ${this.mIndexOfCurrentLine} now using ProgressiveHighlightLineBuilder`);
    }, 500); // æ€»åŠ¨ç”»æ—¶é•¿ï¼š150mså»¶è¿Ÿ + 300msæ ·å¼åŠ¨ç”» + 50msç¼“å†²
  }

  /**
   * è®¡ç®—è¡ŒåŠ¨ç”»å»¶è¿Ÿï¼ˆé”™å¼€åŠ¨ç”»ï¼‰
   */
  private getAnimationDelay(index: number): number {
    if (!this.isAnimating) {
      return 0; // éåŠ¨ç”»çŠ¶æ€æ—¶æ— å»¶è¿Ÿ
    }

    const distance = Math.abs(index - this.mIndexOfCurrentLine);
    // å½“å‰è¡Œæ— å»¶è¿Ÿï¼Œå…¶ä»–è¡Œæ ¹æ®è·ç¦»é€’å¢å»¶è¿Ÿ
    if (distance === 0) {
      return 0; // å½“å‰è¡Œç«‹å³å¼€å§‹åŠ¨ç”»
    } else {
      // è·ç¦»è¶Šè¿œå»¶è¿Ÿè¶Šå¤§ï¼Œä½†ä½¿ç”¨æ›´å°çš„å¢é‡é¿å…è¿‡é•¿å»¶è¿Ÿ
      return Math.min(distance * 15, 80); // æœ€å¤§80mså»¶è¿Ÿ
    }
  }

  /**
   * è®¡ç®—æ­Œè¯è¡Œçš„Yä½ç½®ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œä½¿ç”¨åŸºæœ¬é—´è·ï¼‰
   */
  private calculateLineYPosition(index: number): number {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines || index < 0 || index >= lyricsModel.lines.length) {
      return 0;
    }

    // ç»Ÿä¸€çš„ä½ç½®è®¡ç®—é€»è¾‘
    let currentLineIndex = this.mIndexOfCurrentLine;
    let additionalOffset = 0;

    // è·å–å½“å‰è¡Œçš„å®é™…é«˜åº¦ç”¨äºå±…ä¸­è®¡ç®—
    const currentLine = lyricsModel.lines[currentLineIndex];
    const currentLineHeight = currentLine ?
    this.getDynamicLineHeight(currentLine, this.currentLineTextSize) :
    this.getLineHeight();
    const centerY = (this.actualViewHeight / 2) - (currentLineHeight / 2);

    if (this.mDraggingInProgress && this.originalCurrentLineIndex >= 0) {
      // æ‹–æ‹½æ—¶ï¼šä½¿ç”¨åŸå§‹å½“å‰è¡Œä½œä¸ºåŸºå‡†ï¼ŒåŠ ä¸Šæ‹–æ‹½åç§»
      currentLineIndex = this.originalCurrentLineIndex;
      additionalOffset = this.dragLineOffset * currentLineHeight;

      // è°ƒè¯•ä¿¡æ¯ï¼šè¾“å‡ºä½ç½®è®¡ç®—è¯¦æƒ…
      if (index < 5) {
        LogUtils.d(`LyricsView: Drag calc - Line ${index}, originalIndex: ${this.originalCurrentLineIndex}, dragOffset: ${this.dragLineOffset}, additionalOffset: ${additionalOffset.toFixed(1)}`);
      }
    }

    // åŠ¨æ€ä½ç½®è®¡ç®—ï¼šç´¯ç§¯æ¯è¡Œçš„å®é™…é«˜åº¦
    let yPosition = centerY;

    if (index === currentLineIndex) {
      // å½“å‰è¡Œï¼šåœ¨ä¸­å¿ƒä½ç½®
      yPosition = centerY + additionalOffset;
      LogUtils.d(`LyricsView: ğŸ“ calculateLineYPosition - Line ${index} (CURRENT): centerY=${centerY.toFixed(1)}, additionalOffset=${additionalOffset.toFixed(1)}, result=${yPosition.toFixed(1)}`);
    } else if (index < currentLineIndex) {
      // ä¸Šæ–¹çš„è¡Œï¼šç´¯ç§¯è®¡ç®—å‘ä¸Šçš„åç§»
      let totalOffset = 0;
      for (let i = currentLineIndex - 1; i >= index; i--) {
        const line = lyricsModel.lines[i];
        if (line) {
          const lineHeight = this.getDynamicLineHeight(line, this.textSize);
          totalOffset += lineHeight;
        }
      }
      yPosition = centerY - totalOffset + additionalOffset;
      LogUtils.d(`LyricsView: ğŸ“ calculateLineYPosition - Line ${index} (ABOVE): centerY=${centerY.toFixed(1)}, totalOffset=${totalOffset.toFixed(1)}, additionalOffset=${additionalOffset.toFixed(1)}, result=${yPosition.toFixed(1)}`);
    } else {
      // ä¸‹æ–¹çš„è¡Œï¼šç´¯ç§¯è®¡ç®—å‘ä¸‹çš„åç§»
      let totalOffset = currentLineHeight; // ä»å½“å‰è¡Œåº•éƒ¨å¼€å§‹
      for (let i = currentLineIndex + 1; i <= index; i++) {
        const line = lyricsModel.lines[i];
        if (line) {
          const lineHeight = this.getDynamicLineHeight(line, this.textSize);
          if (i === index) {
            // ç›®æ ‡è¡Œï¼šä¸åŠ ä¸Šè‡ªå·±çš„é«˜åº¦ï¼Œå› ä¸ºyPositionæ˜¯é¡¶éƒ¨ä½ç½®
            break;
          }
          totalOffset += lineHeight;
        }
      }
      yPosition = centerY + totalOffset + additionalOffset;
      LogUtils.d(`LyricsView: ğŸ“ calculateLineYPosition - Line ${index} (BELOW): centerY=${centerY.toFixed(1)}, totalOffset=${totalOffset.toFixed(1)}, additionalOffset=${additionalOffset.toFixed(1)}, result=${yPosition.toFixed(1)}`);
    }

    // æ·»åŠ è¾¹ç•Œæ£€æŸ¥ï¼Œç¡®ä¿æ­Œè¯è¡Œä¸ä¼šå®Œå…¨ç§»å‡ºè§†å›¾
    const targetLine = lyricsModel.lines[index];
    const targetLineHeight = targetLine ?
    this.getDynamicLineHeight(targetLine,
      index === this.mIndexOfCurrentLine ? this.currentLineTextSize : this.textSize) :
    this.getLineHeight();

    const minY = -targetLineHeight * 0.5;
    const maxY = this.actualViewHeight + targetLineHeight * 0.5;

    const clampedY = Math.max(minY, Math.min(maxY, yPosition));

    // å¦‚æœä½ç½®è¢«é™åˆ¶äº†ï¼Œè¾“å‡ºè°ƒè¯•ä¿¡æ¯
    if (this.mDraggingInProgress && Math.abs(clampedY - yPosition) > 1) {
      LogUtils.d(`LyricsView: Line ${index} position clamped from ${yPosition.toFixed(1)} to ${clampedY.toFixed(1)}`);
    }

    return clampedY;
  }

  /**
   * è®¡ç®—æ­Œè¯è¡Œé«˜åº¦
   */
  private getLineHeight(): number {
    return this.currentLineTextSize + this.lineSpacing;
  }

  /**
   * åŠ¨æ€è®¡ç®—ç‰¹å®šæ­Œè¯è¡Œçš„å®é™…æ˜¾ç¤ºé«˜åº¦
   * åªæœ‰å½“æ–‡æœ¬çœŸçš„éœ€è¦å¤šè¡Œæ—¶æ‰å¢åŠ é«˜åº¦
   */
  private getDynamicLineHeight(line: LyricsLineModel, fontSize: number): number {
    if (!this.shouldEnableLineWrap() || !line) {
      return fontSize + this.lineSpacing;
    }

    const text = this.getLineText(line);
    if (!text || text.length === 0) {
      return fontSize + this.lineSpacing;
    }

    // ä¼°ç®—æ–‡æœ¬å®½åº¦
    const textWidth = this.measureTextWidth(text, fontSize);
    const availableWidth = this.actualViewWidth;

    if (availableWidth <= 0 || textWidth <= availableWidth) {
      // ä¸€è¡Œå°±èƒ½æ˜¾ç¤ºå®Œï¼Œä½¿ç”¨æ ‡å‡†è¡Œé«˜
      return fontSize + this.lineSpacing;
    } else {
      // éœ€è¦å¤šè¡Œæ˜¾ç¤ºï¼Œè®¡ç®—å®é™…éœ€è¦çš„è¡Œæ•°
      const estimatedLines = Math.ceil(textWidth / availableWidth);
      const actualLines = Math.min(estimatedLines, 3); // æœ€å¤š3è¡Œ
      return (fontSize * actualLines) + this.lineSpacing;
    }
  }

  /**
   * å°†æ­Œè¯è¡ŒæŒ‰æ˜¾ç¤ºå®½åº¦åˆ†å‰²æˆå¤šä¸ªç‰©ç†è¡Œ
   */
  private splitLineIntoDisplayLines(line: LyricsLineModel, fontSize: number): DisplayLine[] {
    if (!this.shouldEnableLineWrap() || !line || !line.tones || line.tones.length === 0) {
      return [{
        text: this.getLineText(line),
        tones: line.tones || [],
        startTime: line.getStartTime(),
        endTime: line.getEndTime()
      }];
    }

    const availableWidth = this.actualViewWidth;
    if (availableWidth <= 0) {
      return [{
        text: this.getLineText(line),
        tones: line.tones || [],
        startTime: line.getStartTime(),
        endTime: line.getEndTime()
      }];
    }

    const result: DisplayLine[] = [];
    let currentLineText = '';
    let currentLineTones: Tone[] = [];
    let currentLineStartTime = line.getStartTime();
    let currentLineEndTime = line.getStartTime();

    for (let i = 0; i < line.tones.length; i++) {
      const tone = line.tones[i];
      const testText = currentLineText + tone.word;
      const testWidth = this.measureTextWidth(testText, fontSize);

      if (testWidth <= availableWidth || currentLineText === '') {
        // å½“å‰è¡Œè¿˜èƒ½å®¹çº³è¿™ä¸ªå­—ç¬¦ï¼Œæˆ–è€…è¿™æ˜¯ç¬¬ä¸€ä¸ªå­—ç¬¦
        currentLineText += tone.word;
        currentLineTones.push(tone);
        currentLineEndTime = tone.end;
      } else {
        // å½“å‰è¡Œå·²æ»¡ï¼Œå¼€å§‹æ–°è¡Œ
        if (currentLineText !== '') {
          result.push({
            text: currentLineText,
            tones: [...currentLineTones],
            startTime: currentLineStartTime,
            endTime: currentLineEndTime
          });
        }

        // å¼€å§‹æ–°è¡Œ
        currentLineText = tone.word;
        currentLineTones = [tone];
        currentLineStartTime = tone.begin;
        currentLineEndTime = tone.end;
      }
    }

    // æ·»åŠ æœ€åä¸€è¡Œ
    if (currentLineText !== '') {
      result.push({
        text: currentLineText,
        tones: [...currentLineTones],
        startTime: currentLineStartTime,
        endTime: currentLineEndTime
      });
    }

    return result.length > 0 ? result : [{
      text: this.getLineText(line),
      tones: line.tones || [],
      startTime: line.getStartTime(),
      endTime: line.getEndTime()
    }];
  }

  /**
   * è®¡ç®—å¤šè¡Œæ­Œè¯ä¸­ç‰¹å®šç‰©ç†è¡Œçš„é«˜äº®è¿›åº¦
   */
  private calculateDisplayLineProgress(displayLine: DisplayLine, currentTime: number): number {
    if (!displayLine.tones || displayLine.tones.length === 0) {
      return 0;
    }

    if (currentTime < displayLine.startTime) {
      return 0;
    }

    if (currentTime >= displayLine.endTime) {
      return 1;
    }

    // åœ¨è¿™ä¸ªç‰©ç†è¡Œçš„æ—¶é—´èŒƒå›´å†…ï¼Œè®¡ç®—å­—ç¬¦çº§åˆ«çš„è¿›åº¦
    let highlightedChars = 0;
    for (const tone of displayLine.tones) {
      if (currentTime >= tone.end) {
        highlightedChars += tone.word.length;
      } else if (currentTime >= tone.begin) {
        // éƒ¨åˆ†é«˜äº®å½“å‰å­—ç¬¦
        const charProgress = (currentTime - tone.begin) / (tone.end - tone.begin);
        highlightedChars += tone.word.length * charProgress;
        break;
      } else {
        break;
      }
    }

    return Math.min(highlightedChars / displayLine.text.length, 1);
  }

  /**
   * æ”¹è¿›çš„æ–‡æœ¬å®½åº¦ä¼°ç®—æ–¹æ³•
   * æ ¹æ®å­—ç¬¦ç±»å‹è¿›è¡Œæ›´ç²¾ç¡®çš„ä¼°ç®—
   */
  private measureTextWidth(text: string, fontSize: number): number {
    let estimatedWidth = 0;

    let isChinese = false;

    for (let i = 0; i < text.length; i++) {
      const char = text.charAt(i);
      if (/[\u4e00-\u9fa5]/.test(char)) {
        // ä¸­æ–‡å­—ç¬¦ï¼Œå®½åº¦çº¦ç­‰äºå­—ä½“å¤§å°
        estimatedWidth += fontSize;
        isChinese = true;
      } else if (/[a-zA-Z0-9]/.test(char)) {
        // è‹±æ–‡å­—æ¯å’Œæ•°å­—ï¼Œå®½åº¦çº¦ä¸ºå­—ä½“å¤§å°çš„0.5å€
        estimatedWidth += fontSize * 0.5;
      } else {
        // æ ‡ç‚¹ç¬¦å·å’Œå…¶ä»–å­—ç¬¦ï¼Œå®½åº¦çº¦ä¸ºå­—ä½“å¤§å°çš„0.3å€
        if (isChinese) {
          estimatedWidth += fontSize;
        } else {
          estimatedWidth += fontSize * 0.5;
        }
      }
    }

    return estimatedWidth;
  }

  /**
   * æ£€æµ‹æ–‡æœ¬æ˜¯å¦éœ€è¦æ»šåŠ¨ï¼ˆè¶…å‡ºå®¹å™¨å®½åº¦ï¼‰
   */
  private isTextOverflowing(text: string, fontSize: number): boolean {
    const actualTextWidth = this.measureTextWidth(text, fontSize);
    const availableWidth = this.actualViewWidth; // ä½¿ç”¨å®Œæ•´å®½åº¦
    const isOverflowing = actualTextWidth > availableWidth;

    LogUtils.d(`LyricsView: ğŸ“ Text overflow check - text: "${text.substring(0,
      20)}...", length: ${text.length}, fontSize: ${fontSize}, actualWidth: ${actualTextWidth.toFixed(1)}, availableWidth: ${availableWidth.toFixed(1)}, overflowing: ${isOverflowing}, enableLineWrap: ${this.shouldEnableLineWrap()}`);

    // ä¸ºäº†æµ‹è¯•ï¼Œé™ä½æ»šåŠ¨è§¦å‘é˜ˆå€¼
    if (!this.shouldEnableLineWrap()) {
      // å¯¹äºä¸æ¢è¡Œæ¨¡å¼ï¼Œå¦‚æœæ–‡æœ¬é•¿åº¦è¶…è¿‡5ä¸ªå­—ç¬¦å°±è®¤ä¸ºéœ€è¦æ»šåŠ¨ï¼ˆä¾¿äºæµ‹è¯•ï¼‰
      if (text.length > 5) {
        LogUtils.d(`LyricsView: ğŸ”§ Force overflow for testing - text length: ${text.length} > 5, fontSize: ${fontSize}`);
        return true;
      }
    }

    return isOverflowing;
  }

  /**
   * è®¡ç®—æ–‡æœ¬æ»šåŠ¨åç§»é‡
   * è®©æ­£åœ¨æ’­æ”¾çš„éƒ¨åˆ†å§‹ç»ˆä¿æŒåœ¨è§†å›¾ä¸­å¤®
   */
  private calculateTextScrollOffset(line: LyricsLineModel, progress: number): number {
    const text = this.getLineText(line);
    const fontSize = this.currentLineTextSize; // ç¡®ä¿ä½¿ç”¨å½“å‰è¡Œå­—ä½“å¤§å°
    const actualTextWidth = this.measureTextWidth(text, fontSize); // ä½¿ç”¨ç²¾ç¡®æµ‹é‡
    const containerWidth = this.actualViewWidth;

    // ä¸ºäº†æµ‹è¯•ï¼Œå³ä½¿æ–‡æœ¬ä¸æ˜¯å¾ˆé•¿ä¹Ÿå…è®¸æ»šåŠ¨
    if (actualTextWidth <= containerWidth * 0.8) { // é™ä½é˜ˆå€¼ï¼Œ80%å°±å¼€å§‹æ»šåŠ¨
      return 0; // æ–‡æœ¬ä¸å¤Ÿé•¿ï¼Œæ— éœ€æ»šåŠ¨
    }

    // è®¡ç®—å½“å‰æ’­æ”¾ä½ç½®çš„åƒç´ åç§»
    const currentPlayPosition = actualTextWidth * progress;
    const halfContainerWidth = containerWidth / 2;

    // è®©å½“å‰æ’­æ”¾ä½ç½®ä¿æŒåœ¨å®¹å™¨ä¸­å¤®
    let targetOffset = currentPlayPosition - halfContainerWidth;

    // é™åˆ¶æ»šåŠ¨èŒƒå›´ï¼šä¸èƒ½æ»šåŠ¨åˆ°è´Ÿå€¼ï¼Œä¹Ÿä¸èƒ½è¶…è¿‡æœ€å¤§æ»šåŠ¨è·ç¦»
    const maxScrollOffset = actualTextWidth - containerWidth;
    targetOffset = Math.max(0, Math.min(targetOffset, maxScrollOffset));

    return targetOffset;
  }

  /**
   * å¯åŠ¨æ–‡æœ¬æ»šåŠ¨åŠ¨ç”»
   */
  private startTextScrollAnimation(line: LyricsLineModel): void {
    const text = this.getLineText(line);
    LogUtils.d(`LyricsView: ğŸš€ startTextScrollAnimation called - text: "${text.substring(0,
      30)}...", enableLineWrap: ${this.shouldEnableLineWrap()}`);

    // é‡ç½®æ»šåŠ¨åç§»ï¼Œä¸ºæ–°è¡Œå‡†å¤‡
    this.currentLineScrollOffset = 0;

    if (this.shouldEnableLineWrap()) {
      LogUtils.d(`LyricsView: âŒ Line wrap enabled, skipping scroll animation`);
      return; // å¯ç”¨æ¢è¡Œæ—¶ä¸éœ€è¦æ»šåŠ¨
    }

    if (!this.isTextOverflowing(text, this.currentLineTextSize)) {
      LogUtils.d(`LyricsView: âŒ Text not overflowing, skipping scroll animation`);
      return; // æ–‡æœ¬ä¸è¶…é•¿æ—¶ä¸éœ€è¦æ»šåŠ¨
    }

    this.isTextScrolling = true;
    this.textScrollOffset = 0;
    // currentLineScrollOffset å·²ç»åœ¨ä¸Šé¢é‡ç½®äº†

    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (this.textScrollTimer !== -1) {
      clearInterval(this.textScrollTimer);
    }

    LogUtils.d(`LyricsView: âœ… Starting text scroll animation for line: "${text.substring(0,
      20)}...", textLength: ${text.length}, fontSize: ${this.currentLineTextSize}, viewWidth: ${this.actualViewWidth}`);

    // å¯åŠ¨æ»šåŠ¨å®šæ—¶å™¨ï¼Œæ¯50msæ›´æ–°ä¸€æ¬¡ä»¥è·å¾—æ›´æµç•…çš„æ•ˆæœ
    this.textScrollTimer = setInterval(() => {
      if (!this.isTextScrolling) {
        LogUtils.d(`LyricsView: â¹ï¸ Scroll timer stopped - isTextScrolling: false`);
        return;
      }

      const progress = this.calculateLineProgress(line);
      const targetOffset = this.calculateTextScrollOffset(line, progress);

      // ä½¿ç”¨textScroller.scrollToå®ç°çœŸæ­£çš„æ»šåŠ¨
      if (Math.abs(this.currentLineScrollOffset - targetOffset) > 0.5) {
        const oldOffset = this.currentLineScrollOffset;
        this.currentLineScrollOffset = targetOffset;

        // ä½¿ç”¨Scrollerè¿›è¡Œæ»šåŠ¨
        this.textScroller.scrollTo({
          xOffset: targetOffset,
          yOffset: 0,
          animation: {
            duration: 100,
            curve: Curve.EaseOut
          }
        });

        LogUtils.d(`LyricsView: ğŸ”„ Scroll update - progress: ${(progress *
          100).toFixed(1)}%, oldOffset: ${oldOffset.toFixed(1)}px, newOffset: ${targetOffset.toFixed(1)}px, scrollTo: ${targetOffset.toFixed(1)}px`);
      }
    }, 50);
  }

  /**
   * åœæ­¢æ–‡æœ¬æ»šåŠ¨åŠ¨ç”»
   */
  private stopTextScrollAnimation(): void {
    if (this.textScrollTimer !== -1) {
      clearInterval(this.textScrollTimer);
      this.textScrollTimer = -1;
    }
    this.isTextScrolling = false;
    this.textScrollOffset = 0;
    this.mCurrentLineTranslateX = 0; // é‡ç½®æ°´å¹³æ»šåŠ¨åç§»
    // é‡ç½®æ»šåŠ¨ä½ç½®åˆ°å¼€å§‹
    this.textScroller.scrollTo({
      xOffset: 0,
      yOffset: 0
    });
    LogUtils.d(`LyricsView: ğŸ›‘ Text scroll animation stopped and reset to start`);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦åº”ç”¨æ¨ªå‘æ»šåŠ¨ï¼ˆå‚è€ƒAndroidç‰ˆæœ¬å®ç°ï¼‰
   * å½“é«˜äº®éƒ¨åˆ†å’Œå‰©ä½™éƒ¨åˆ†éƒ½å¤§äºè§†å›¾å®½åº¦çš„ä¸€åŠæ—¶ï¼Œå¼€å§‹æ»šåŠ¨
   */
  private checkIfXTranslationShouldApply(line: LyricsLineModel): void {
    if (this.shouldEnableLineWrap()) {
      this.mCurrentLineTranslateX = 0; // æ¢è¡Œæ¨¡å¼ä¸‹ä¸éœ€è¦æ¨ªå‘æ»šåŠ¨
      this.updateScrollPosition(0);
      return;
    }

    const text = this.getLineText(line);
    const fontSize = this.currentLineTextSize;
    const textWidth = text.length * fontSize * 0.6; // ä¼°ç®—æ–‡æœ¬æ€»å®½åº¦
    const viewWidth = this.actualViewWidth;
    const halfViewWidth = viewWidth / 2;

    // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦è¶…é•¿
    if (!this.isLyricsLineOverlong(textWidth)) {
      this.mCurrentLineTranslateX = 0;
      this.updateScrollPosition(0);
      return;
    }

    // è®¡ç®—å½“å‰é«˜äº®åŒºåŸŸå®½åº¦
    const progress = this.calculateLineProgress(line);
    const currentHighlightWidth = textWidth * progress;
    this.mRectClipWidth = currentHighlightWidth;

    // Androidç‰ˆæœ¬çš„æ»šåŠ¨é€»è¾‘ï¼š
    // 1. é«˜äº®éƒ¨åˆ†å¤§äºè§†å›¾å®½åº¦çš„ä¸€åŠ
    // 2. å‰©ä½™éƒ¨åˆ†ä¹Ÿå¤§äºè§†å›¾å®½åº¦çš„ä¸€åŠ
    if (currentHighlightWidth > halfViewWidth &&
      (textWidth - currentHighlightWidth) > halfViewWidth) {

      // è®¡ç®—ç›®æ ‡æ»šåŠ¨ä½ç½®ï¼šè®©å½“å‰æ’­æ”¾ä½ç½®ä¿æŒåœ¨å±å¹•ä¸­å¤®
      const targetScrollX = currentHighlightWidth - halfViewWidth;

      // é™åˆ¶æ»šåŠ¨èŒƒå›´
      const maxScroll = textWidth - viewWidth;
      this.mCurrentLineTranslateX = Math.max(0, Math.min(maxScroll, targetScrollX));

      // åº”ç”¨æ»šåŠ¨
      this.updateScrollPosition(this.mCurrentLineTranslateX);

      LogUtils.d(`LyricsView: Horizontal scroll - progress: ${(progress *
        100).toFixed(1)}%, highlightWidth: ${currentHighlightWidth.toFixed(1)}, targetScrollX: ${targetScrollX.toFixed(1)}, actualScrollX: ${this.mCurrentLineTranslateX.toFixed(1)}`);
    } else {
      this.mCurrentLineTranslateX = 0;
      this.updateScrollPosition(0);
    }

    // æ›´æ–°ä¸Šæ¬¡é«˜äº®åŒºåŸŸå³è¾¹ç•Œ
    this.mLastRightOfRectClip = currentHighlightWidth;
  }

  /**
   * æ›´æ–°æ»šåŠ¨ä½ç½®
   */
  private updateScrollPosition(scrollX: number): void {
    if (this.textScroller) {
      this.textScroller.scrollTo({
        xOffset: scrollX,
        yOffset: 0
      });
    }
  }

  /**
   * æ£€æŸ¥æ­Œè¯è¡Œæ˜¯å¦è¶…é•¿ï¼ˆéœ€è¦æ¨ªå‘æ»šåŠ¨ï¼‰
   */
  private isLyricsLineOverlong(textWidth: number): boolean {
    return textWidth > this.actualViewWidth;
  }

  /**
   * è®¡ç®—é«˜äº®åŒºåŸŸå®½åº¦ï¼ˆåƒç´ å€¼ï¼‰
   */
  private calculateHighlightWidthPx(line: LyricsLineModel): number {
    const progress = this.calculateLineProgress(line);
    const text = this.getLineText(line);
    const fontSize = this.currentLineTextSize;
    const totalWidth = text.length * fontSize * 0.6;
    return totalWidth * progress;
  }

  /**
   * è®¡ç®—å¯ä»¥æ˜¾ç¤ºçš„æœ€å¤§è¡Œæ•°ï¼ˆä¸Šä¸‹å„ä¸€åŠï¼‰
   */
  private getMaxVisibleLines(): number {
    const lineHeight = this.getLineHeight();
    const availableHeight = this.actualViewHeight;
    return Math.floor(availableHeight / lineHeight);
  }

  /**
   * åˆ¤æ–­æ­Œè¯è¡Œæ˜¯å¦åœ¨å¯è§†èŒƒå›´å†…
   */
  private isLineVisible(index: number): boolean {
    // è®¡ç®—è¯¥è¡Œçš„å®é™…Yä½ç½®
    const lineY = this.calculateLineYPosition(index);
    const lineHeight = this.getLineHeight();

    // åˆ¤æ–­è¡Œæ˜¯å¦åœ¨è§†å›¾èŒƒå›´å†…ï¼ˆåŒ…å«éƒ¨åˆ†å¯è§ï¼‰
    const lineTop = lineY;
    const lineBottom = lineY + lineHeight;
    const viewTop = -lineHeight * 0.5; // å…è®¸ç¨å¾®è¶…å‡ºä¸Šè¾¹ç•Œ
    const viewBottom = this.actualViewHeight + lineHeight * 0.5; // å…è®¸ç¨å¾®è¶…å‡ºä¸‹è¾¹ç•Œ

    // å¦‚æœè¡Œçš„ä»»ä½•éƒ¨åˆ†åœ¨æ‰©å±•è§†å›¾èŒƒå›´å†…ï¼Œå°±è®¤ä¸ºæ˜¯å¯è§çš„
    const isVisible = lineBottom > viewTop && lineTop < viewBottom;

    // åœ¨æ‹–æ‹½æ—¶è¾“å‡ºè¯¦ç»†è°ƒè¯•ä¿¡æ¯
    if (this.mDraggingInProgress && index < 10) {
      LogUtils.d(`LyricsView: Line ${index} - Y: ${lineY.toFixed(1)}, Top: ${lineTop.toFixed(1)}, Bottom: ${lineBottom.toFixed(1)}, ViewTop: ${viewTop}, ViewBottom: ${viewBottom}, Visible: ${isVisible}`);
    }

    return isVisible;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥æ¸²æŸ“æŸä¸€è¡Œï¼ˆåŸºäºenablePreviousLineså’ŒenableUpcomingLineså¼€å…³ï¼‰
   */
  private shouldRenderLine(index: number): boolean {
    // ç¡®å®šå½“å‰å‚è€ƒè¡Œç´¢å¼•
    const currentIndex = this.mDraggingInProgress && this.originalCurrentLineIndex >= 0
      ? this.originalCurrentLineIndex
      : this.mIndexOfCurrentLine;

    // å½“å‰è¡Œå§‹ç»ˆæ¸²æŸ“
    if (index === currentIndex) {
      return true;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¹‹å‰çš„è¡Œ
    if (index < currentIndex) {
      return this.enablePreviousLines;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯æœªæ¥çš„è¡Œ
    if (index > currentIndex) {
      return this.enableUpcomingLines;
    }

    return true;
  }

  /**
   * ç»Ÿè®¡å¹¶è®°å½•å½“å‰å¯è§çš„è¡Œæ•°ï¼ˆè°ƒè¯•ç”¨ï¼‰
   */
  private logVisibleLinesCount(): void {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines) {
      return;
    }

    let visibleCount = 0;
    let renderedCount = 0;
    const visibleLines: number[] = [];
    const renderedLines: number[] = [];

    for (let i = 0; i < lyricsModel.lines.length; i++) {
      if (this.shouldRenderLine(i)) {
        renderedCount++;
        renderedLines.push(i);

        if (this.isLineVisible(i)) {
          visibleCount++;
          visibleLines.push(i);
        }
      }
    }

    LogUtils.d(`LyricsView: Rendered lines: ${renderedCount}, Visible lines: ${visibleCount}, Total: ${lyricsModel.lines.length}, Previous: ${this.enablePreviousLines}, Upcoming: ${this.enableUpcomingLines}`);

    // å¦‚æœæ²¡æœ‰å¯è§è¡Œï¼Œè¿™æ˜¯ä¸€ä¸ªé—®é¢˜
    if (visibleCount === 0) {
      LogUtils.d(`LyricsView: WARNING - No visible lines! ViewHeight: ${this.actualViewHeight}, LineHeight: ${this.getLineHeight()}`);
    }
  }

  /**
   * æ¸è¿›å¼é«˜äº®æ­Œè¯è¡ŒBuilder - å®ç°å¡æ‹‰OKé£æ ¼çš„æµç•…é«˜äº®æ•ˆæœ
   */
  @Builder
  EnhancedLyricsLineBuilder(line: LyricsLineModel, index: number) {
    // æ¸²æŸ“æ‰€æœ‰è¡Œï¼Œä½†ä½¿ç”¨é€æ˜åº¦æ§åˆ¶å¯è§æ€§ï¼Œç¡®ä¿åŠ¨ç”»è¿ç»­æ€§
    if (index === this.mIndexOfCurrentLine && this.newCurrentTransitioning) {
      // æ–°å½“å‰è¡Œæ­£åœ¨è¿‡æ¸¡ï¼šä½¿ç”¨æ–°å½“å‰è¡Œè¿‡æ¸¡æ•ˆæœ
      this.NewCurrentLineTransitionBuilder(line, index)
    } else if (index === this.mIndexOfCurrentLine) {
      // å½“å‰è¡Œï¼šä½¿ç”¨æ¸è¿›å¼é«˜äº®æ•ˆæœ
      this.ProgressiveHighlightLineBuilder(line, index)
    } else if (index === this.transitioningFromIndex && this.isAnimating) {
      // æ­£åœ¨è¿‡æ¸¡çš„åŸå½“å‰è¡Œï¼šä½¿ç”¨è¿‡æ¸¡é«˜äº®æ•ˆæœ
      this.TransitioningHighlightLineBuilder(line, index)
    } else {
      // éå½“å‰è¡Œï¼šæ™®é€šæ˜¾ç¤º
      this.NormalLineBuilder(line, index)
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åº”è¯¥å¯ç”¨æ¢è¡Œï¼ˆLRCæ ¼å¼é»˜è®¤å¯ç”¨ï¼‰
   */
  private shouldEnableLineWrap(): boolean {
    // å¦‚æœæ˜ç¡®è®¾ç½®äº†enableLineWrapï¼Œä½¿ç”¨è®¾ç½®å€¼
    if (this.enableLineWrap !== undefined) {
      return this.enableLineWrap;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯LRCæ ¼å¼ï¼ˆé€šè¿‡æ£€æŸ¥æ­Œè¯æ¨¡å‹çš„ç±»å‹ï¼‰
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (lyricsModel && lyricsModel.type === LyricType.LRC) {
      LogUtils.d(`LyricsView: LRC format detected, enabling line wrap by default`);
      return true; // LRCæ ¼å¼é»˜è®¤å¯ç”¨æ¢è¡Œ
    }

    LogUtils.d(`LyricsView: Non-LRC format or no lyrics model, disabling line wrap by default`);
    return false; // å…¶ä»–æ ¼å¼é»˜è®¤ä¸å¯ç”¨æ¢è¡Œ
  }

  /**
   * æ¸è¿›å¼é«˜äº®è¡ŒBuilder
   */
  @Builder
  ProgressiveHighlightLineBuilder(line: LyricsLineModel, index: number) {
    if (this.shouldEnableLineWrap()) {
      // å¯ç”¨æ¢è¡Œæ¨¡å¼
      this.WrappedHighlightLineBuilder(line, index);
    } else {
      // æ»šåŠ¨æ¨¡å¼
      this.ScrollingHighlightLineBuilder(line, index);
    }
  }

  /**
   * æ¢è¡Œé«˜äº®è¡ŒBuilder
   */
  @Builder
  WrappedHighlightLineBuilder(line: LyricsLineModel, index: number) {
    Stack() {
      // èƒŒæ™¯æ–‡å­—ï¼ˆæ­£å¸¸é¢œè‰²ï¼‰
      Column() {
        ForEach(this.splitLineIntoDisplayLines(line, this.currentLineTextSize),
          (displayLine: DisplayLine, displayIndex: number) => {
            Row() {
              Text(displayLine.text)
                .fontSize(this.currentLineTextSize)
                .fontColor(this.currentLineTextColor)
                .fontWeight(FontWeight.Bold)
                .textAlign(this.getTextAlign())
                .width('100%')
                .maxLines(1) // æ¯ä¸ªç‰©ç†è¡Œéƒ½æ˜¯å•è¡Œ
                .textOverflow({ overflow: TextOverflow.None })
            }
            .width('100%')
            .justifyContent(this.getRowJustifyContent())
            .height(this.currentLineTextSize)
          }, (displayLine: DisplayLine, displayIndex: number) => `${index}_bg_${displayIndex}`)
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)

      // é«˜äº®æ–‡å­—ï¼ˆé€è¡Œæ¸è¿›é«˜äº®ï¼‰
      Column() {
        ForEach(this.splitLineIntoDisplayLines(line, this.currentLineTextSize),
          (displayLine: DisplayLine, displayIndex: number) => {
            Row() {
              Text(displayLine.text)
                .fontSize(this.currentLineTextSize)
                .fontColor(this.currentLineHighlightedTextColor)
                .fontWeight(FontWeight.Bold)
                .textAlign(this.getTextAlign())
                .width('100%')
                .maxLines(1) // æ¯ä¸ªç‰©ç†è¡Œéƒ½æ˜¯å•è¡Œ
                .textOverflow({ overflow: TextOverflow.None })
            }
            .width('100%')
            .justifyContent(this.getRowJustifyContent())
            .height(this.currentLineTextSize)
            .clip(true)
            .clipShape(new Rect({
              width: `${this.calculateDisplayLineProgress(displayLine, this.mCurrentTime) * 100}%`,
              height: '100%'
            }))
            .animation({
              duration: 50, // æ›´å¿«çš„é«˜äº®å“åº”
              curve: Curve.Linear,
              iterations: 1,
              playMode: PlayMode.Normal
            })
          }, (displayLine: DisplayLine, displayIndex: number) => `${index}_fg_${displayIndex}`)
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
    }
    .width('100%')
    .height(this.getDynamicLineHeight(line, this.currentLineTextSize))
    .position({ x: 0, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * æ»šåŠ¨é«˜äº®è¡ŒBuilderï¼ˆå•è¡Œæ˜¾ç¤ºï¼Œæ”¯æŒæ¨ªå‘æ»šåŠ¨åŠ¨ç”»ï¼‰
   */
  @Builder
  ScrollingHighlightLineBuilder(line: LyricsLineModel, index: number) {
    // ä½¿ç”¨Scrollç»„ä»¶å®ç°çœŸæ­£çš„æ¨ªå‘æ»šåŠ¨
    Scroll(this.textScroller) {
      Stack() {
        // èƒŒæ™¯æ–‡å­—ï¼ˆæ­£å¸¸é¢œè‰²ï¼Œå•è¡Œæ˜¾ç¤ºï¼‰
        Text(this.getLineText(line))
          .fontSize(this.currentLineTextSize)
          .fontColor(this.currentLineTextColor)
          .fontWeight(FontWeight.Bold)
          .textAlign(this.getTextAlign())
          .maxLines(1) // å•è¡Œæ˜¾ç¤º
          .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
          .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
          .onAppear(() => {
            LogUtils.d(`LyricsView: ğŸ¨ Background text rendered - scrollOffset: ${this.currentLineScrollOffset}, text: "${this.getLineText(line)
              .substring(0, 15)}..."`);
          })

        // é«˜äº®æ–‡å­—ï¼ˆä½¿ç”¨clipå®ç°æ¸è¿›æ•ˆæœï¼‰
        Text(this.getLineText(line))
          .fontSize(this.currentLineTextSize)
          .fontColor(this.currentLineHighlightedTextColor)
          .fontWeight(FontWeight.Bold)
          .textAlign(this.getTextAlign())
          .maxLines(1) // å•è¡Œæ˜¾ç¤º
          .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
          .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
          .clip(true)
          .clipShape(new Rect({
            width: `${this.calculateLineProgress(line) * 100}%`, // ä½¿ç”¨ç™¾åˆ†æ¯”ç¡®ä¿æ­£ç¡®å¯¹é½
            height: '100%'
          }))
          .animation({
            duration: 50, // æ›´å¿«çš„é«˜äº®å“åº”
            curve: Curve.Linear,
            iterations: 1,
            playMode: PlayMode.Normal
          })
      }
      .alignContent(this.getAlignment())
    }
    .scrollable(ScrollDirection.Horizontal) // æ°´å¹³æ»šåŠ¨
    .scrollBar(BarState.Off) // éšè—æ»šåŠ¨æ¡
    .width('100%')
    .height(this.getLineHeight())
    .position({ x: 0, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * è¿‡æ¸¡æ™®é€šè¡ŒBuilder - å¤„ç†åŸå½“å‰è¡Œä»¥æ™®é€šè¡Œæ ·å¼ä»å½“å‰ä½ç½®ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
   */
  @Builder
  TransitioningHighlightLineBuilder(line: LyricsLineModel, index: number) {
    // æ ¹æ®enableLineWrapå†³å®šæ˜¾ç¤ºæ–¹å¼
    if (this.shouldEnableLineWrap()) {
      // æ¢è¡Œæ¨¡å¼ï¼šæ”¯æŒå¤šè¡Œæ˜¾ç¤º
      Row() {
        Text(this.getLineText(line))
          .fontSize(this.textSize) // ä½¿ç”¨æ™®é€šè¡Œå­—ä½“å¤§å°
          .fontColor(this.getNormalLineColor(index)) // ä½¿ç”¨æ™®é€šè¡Œé¢œè‰²
          .fontWeight(FontWeight.Normal) // ä½¿ç”¨æ™®é€šè¡Œå­—é‡
          .textAlign(this.getTextAlign())
          .width('100%')
          .maxLines(3) // æœ€å¤š3è¡Œ
          .textOverflow({ overflow: TextOverflow.Ellipsis })
      }
      .width('100%')
      .height(this.getDynamicLineHeight(line, this.textSize))
      .justifyContent(this.getRowJustifyContent())
      .alignItems(VerticalAlign.Center)
      .position({
        x: 0,
        y: this.getTransitioningYPosition() // ä½¿ç”¨åŠ¨ç”»æ’å€¼ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getTransitioningLineScale(index),
        y: this.getTransitioningLineScale(index)
      })
      .animation({
        duration: 400, // ä½ç½®å’Œç¼©æ”¾åŠ¨ç”»
        curve: Curve.EaseInOut,
        iterations: 1,
        playMode: PlayMode.Normal
      })
    } else {
      // ä¸æ¢è¡Œæ¨¡å¼ï¼šä½¿ç”¨Scrollç»„ä»¶é¿å…å­—ä½“å˜åŒ–æ—¶çš„é—ªåŠ¨
      Scroll() {
        Stack() {
          Text(this.getLineText(line))
            .fontSize(this.textSize) // ä½¿ç”¨æ™®é€šè¡Œå­—ä½“å¤§å°
            .fontColor(this.getNormalLineColor(index)) // ä½¿ç”¨æ™®é€šè¡Œé¢œè‰²
            .fontWeight(FontWeight.Normal) // ä½¿ç”¨æ™®é€šè¡Œå­—é‡
            .textAlign(this.getTextAlign()) // å·¦å¯¹é½
            .maxLines(1) // å•è¡Œæ˜¾ç¤º
            .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
            .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
        }
        .alignContent(this.getAlignment())
      }
      .scrollable(ScrollDirection.Horizontal) // æ°´å¹³æ»šåŠ¨
      .scrollBar(BarState.Off) // éšè—æ»šåŠ¨æ¡
      .width('100%')
      .height(this.getLineHeight())
      .position({
        x: 0,
        y: this.getTransitioningYPosition() // ä½¿ç”¨åŠ¨ç”»æ’å€¼ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getTransitioningLineScale(index),
        y: this.getTransitioningLineScale(index)
      })
      .animation({
        duration: 400, // ä½ç½®å’Œç¼©æ”¾åŠ¨ç”»
        curve: Curve.EaseInOut,
        iterations: 1,
        playMode: PlayMode.Normal
      })
    }
  }

  /**
   * æ–°å½“å‰è¡Œè¿‡æ¸¡Builder - å¤„ç†ä»ä¸‹ä¸€è¡Œä½ç½®ç§»åŠ¨åˆ°ä¸­å¿ƒå¹¶å˜ä¸ºé«˜äº®æ ·å¼
   */
  @Builder
  NewCurrentLineTransitionBuilder(line: LyricsLineModel, index: number) {
    // æ ¹æ®enableLineWrapå†³å®šæ˜¾ç¤ºæ–¹å¼
    if (this.shouldEnableLineWrap()) {
      // æ¢è¡Œæ¨¡å¼ï¼šä½¿ç”¨Stackå¸ƒå±€
      Stack() {
        // èƒŒæ™¯æ–‡å­—ï¼ˆå¹³æ»‘è¿‡æ¸¡æ ·å¼ï¼‰
        Row() {
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize())
            .fontColor(this.getTransitioningTextColor())
            .fontWeight(this.getTransitioningFontWeight())
            .textAlign(this.getTextAlign())
            .width('100%')
            .maxLines(3) // æœ€å¤š3è¡Œ
            .textOverflow({ overflow: TextOverflow.Ellipsis })
            .animation({
              duration: 300, // æ ·å¼è¿‡æ¸¡åŠ¨ç”»
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })
        }
        .width('100%')
        .justifyContent(this.getRowJustifyContent())

        // é«˜äº®æ–‡å­—ï¼ˆæ¸è¿›æ˜¾ç¤ºï¼‰- å§‹ç»ˆæ˜¾ç¤ºï¼Œä½†åœ¨åŠ¨ç”»æœŸé—´ä½¿ç”¨ç›¸åŒçš„å­—ä½“å¤§å°
        Row() {
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—ä½“å¤§å°ï¼Œç¡®ä¿å®Œå…¨å¯¹é½
            .fontColor(this.currentLineHighlightedTextColor)
            .fontWeight(this.getTransitioningFontWeight()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—é‡
            .textAlign(this.getTextAlign())
            .width('100%')
            .maxLines(3) // æœ€å¤š3è¡Œ
            .textOverflow({ overflow: TextOverflow.Ellipsis })
            .animation({
              duration: 300, // æ ·å¼è¿‡æ¸¡åŠ¨ç”»ï¼Œä¸èƒŒæ™¯æ–‡å­—åŒæ­¥
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })
        }
        .width('100%')
        .justifyContent(this.getRowJustifyContent())
        .clip(true)
        .clipShape(new Rect({
          width: `${this.calculateLineProgress(line) * 100}%`,
          height: '100%'
        }))
        .opacity(this.styleTransitioning ? 1.0 : 0.0) // æ ·å¼è¿‡æ¸¡å¼€å§‹åæ‰æ˜¾ç¤ºé«˜äº®
        .animation({
          duration: 300, // é«˜äº®æ¸å…¥åŠ¨ç”»
          curve: Curve.EaseInOut,
          iterations: 1,
          playMode: PlayMode.Normal
        })
      }
      .width('100%')
      .height(this.getDynamicLineHeight(line, this.currentLineTextSize))
      .alignContent(this.getAlignment())
      .position({
        x: 0,
        y: this.getNewCurrentYPosition() // ä½¿ç”¨æ–°å½“å‰è¡Œçš„ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getNewCurrentScale(),
        y: this.getNewCurrentScale()
      })
      .animation({
        duration: 400, // ä½ç½®å’Œç¼©æ”¾åŠ¨ç”»
        curve: Curve.EaseInOut,
        iterations: 1,
        playMode: PlayMode.Normal
      })
    } else {
      // ä¸æ¢è¡Œæ¨¡å¼ï¼šä½¿ç”¨Scrollç»„ä»¶é¿å…é—ªåŠ¨
      Scroll(this.textScroller) {
        Stack() {
          // èƒŒæ™¯æ–‡å­—ï¼ˆå•è¡Œæ˜¾ç¤ºï¼‰
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize())
            .fontColor(this.getTransitioningTextColor())
            .fontWeight(this.getTransitioningFontWeight())
            .textAlign(this.getTextAlign()) // å·¦å¯¹é½
            .maxLines(1) // å•è¡Œæ˜¾ç¤º
            .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
            .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
            .animation({
              duration: 300, // æ ·å¼è¿‡æ¸¡åŠ¨ç”»
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })

          // é«˜äº®æ–‡å­—ï¼ˆæ¸è¿›æ˜¾ç¤ºï¼Œå•è¡Œï¼‰- å§‹ç»ˆæ˜¾ç¤ºï¼Œä½†åœ¨åŠ¨ç”»æœŸé—´ä½¿ç”¨ç›¸åŒçš„å­—ä½“å¤§å°
          Text(this.getLineText(line))
            .fontSize(this.getTransitioningFontSize()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—ä½“å¤§å°ï¼Œç¡®ä¿å®Œå…¨å¯¹é½
            .fontColor(this.currentLineHighlightedTextColor)
            .fontWeight(this.getTransitioningFontWeight()) // ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡å­—é‡
            .textAlign(this.getTextAlign()) // å·¦å¯¹é½
            .maxLines(1) // å•è¡Œæ˜¾ç¤º
            .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
            .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
            .clip(true)
            .clipShape(new Rect({
              width: `${this.calculateLineProgress(line) * 100}%`,
              height: '100%'
            }))
            .opacity(this.styleTransitioning ? 1.0 : 0.0) // æ ·å¼è¿‡æ¸¡å¼€å§‹åæ‰æ˜¾ç¤ºé«˜äº®
            .animation({
              duration: 300, // é«˜äº®æ¸å…¥åŠ¨ç”»
              curve: Curve.EaseInOut,
              iterations: 1,
              playMode: PlayMode.Normal
            })
        }
        .alignContent(this.getAlignment())
      }
      .scrollable(ScrollDirection.Horizontal) // æ°´å¹³æ»šåŠ¨
      .scrollBar(BarState.Off) // éšè—æ»šåŠ¨æ¡
      .width('100%')
      .height(this.getLineHeight())
      .position({
        x: 0,
        y: this.getNewCurrentYPosition() // ä½¿ç”¨æ–°å½“å‰è¡Œçš„ä½ç½®
      })
      .opacity(this.getLineOpacity(index))
      .scale({
        x: this.getNewCurrentScale(),
        y: this.getNewCurrentScale()
      })
      .animation({
        duration: 400, // ä½ç½®å’Œç¼©æ”¾åŠ¨ç”»
        curve: Curve.EaseInOut,
        iterations: 1,
        playMode: PlayMode.Normal
      })
    }
  }

  /**
   * æ™®é€šè¡ŒBuilder
   */
  @Builder
  NormalLineBuilder(line: LyricsLineModel, index: number) {
    if (this.shouldEnableLineWrap()) {
      // æ¢è¡Œæ¨¡å¼ï¼šæ™®é€šè¡Œæ”¯æŒæ¢è¡Œ
      this.WrappedNormalLineBuilder(line, index);
    } else {
      // ä¸æ¢è¡Œæ¨¡å¼ï¼šæ™®é€šè¡Œå•è¡Œæ˜¾ç¤ºï¼Œä¸æ˜¾ç¤ºçœç•¥å·
      this.SingleLineNormalBuilder(line, index);
    }
  }

  /**
   * æ¢è¡Œæ™®é€šè¡ŒBuilder
   */
  @Builder
  WrappedNormalLineBuilder(line: LyricsLineModel, index: number) {
    Row() {
      Text(this.getLineText(line))
        .fontSize(this.textSize)
        .fontColor(this.getNormalLineColor(index))
        .fontWeight(FontWeight.Normal)
        .textAlign(this.getTextAlign())
        .width('100%')
        .maxLines(3) // æœ€å¤š3è¡Œ
        .textOverflow({ overflow: TextOverflow.Ellipsis })
    }
    .width('100%')
    .height(this.getDynamicLineHeight(line, this.textSize))
    .justifyContent(this.getRowJustifyContent())
    .alignItems(VerticalAlign.Center)
    .position({ x: 0, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿ï¼Œä¸é«˜äº®è¡Œä¿æŒä¸€è‡´
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * å•è¡Œæ™®é€šè¡ŒBuilderï¼ˆä¸æ¢è¡Œï¼Œä¸æ˜¾ç¤ºçœç•¥å·ï¼‰
   */
  @Builder
  SingleLineNormalBuilder(line: LyricsLineModel, index: number) {
    Stack() {
      Text(this.getLineText(line))
        .fontSize(this.textSize)
        .fontColor(this.getNormalLineColor(index))
        .fontWeight(FontWeight.Normal)
        .textAlign(this.getTextAlign())
        .maxLines(1) // å•è¡Œæ˜¾ç¤º
        .textOverflow({ overflow: TextOverflow.None }) // ä¸æ˜¾ç¤ºçœç•¥å·
        .width('auto') // è®©æ–‡æœ¬è‡ªç„¶å®½åº¦
    }
    .width('100%')
    .height(this.getLineHeight())
    .alignContent(this.getAlignment())
    .clip(true) // è£å‰ªè¶…å‡ºéƒ¨åˆ†ï¼Œä¸æ˜¾ç¤ºçœç•¥å·
    .position({ x: 0, y: this.calculateLineYPosition(index) })
    .opacity(this.getLineOpacity(index))
    .scale({
      x: this.getLineScale(index),
      y: this.getLineScale(index)
    })
    .animation({
      duration: 400, // ç»Ÿä¸€åŠ¨ç”»æ—¶é•¿ï¼Œä¸é«˜äº®è¡Œä¿æŒä¸€è‡´
      delay: this.getAnimationDelay(index), // é”™å¼€åŠ¨ç”»å»¶è¿Ÿ
      curve: Curve.EaseInOut,
      iterations: 1,
      playMode: PlayMode.Normal
    })
  }

  /**
   * è®¡ç®—å½“å‰è¡Œçš„é«˜äº®è¿›åº¦ï¼ˆ0-1ä¹‹é—´ï¼‰
   * åŸºäºå­—ç¬¦çº§åˆ«çš„ç²¾ç¡®è¿›åº¦è®¡ç®—
   */
  private calculateLineProgress(line: LyricsLineModel): number {
    if (!line.tones || line.tones.length === 0) {
      return 0;
    }

    const lineStartTime = line.getStartTime();
    const lineEndTime = line.getEndTime();

    if (this.mCurrentTime < lineStartTime) {
      return 0;
    } else if (this.mCurrentTime >= lineEndTime) {
      return 1;
    }

    // åŸºäºå­—ç¬¦çº§åˆ«çš„è¿›åº¦è®¡ç®—
    let totalChars = 0;
    let playedChars = 0;

    for (const tone of line.tones) {
      const charLength = tone.word.length;
      totalChars += charLength;

      if (this.mCurrentTime >= tone.begin) {
        if (this.mCurrentTime >= tone.end) {
          // æ•´ä¸ªå­—ç¬¦éƒ½å·²æ’­æ”¾
          playedChars += charLength;
        } else {
          // å­—ç¬¦æ­£åœ¨æ’­æ”¾ä¸­ï¼Œè®¡ç®—éƒ¨åˆ†è¿›åº¦
          const toneProgress = (this.mCurrentTime - tone.begin) / (tone.end - tone.begin);
          playedChars += charLength * toneProgress;
        }
      }
    }

    return totalChars > 0 ? Math.min(1, playedChars / totalChars) : 0;
  }

  /**
   * è·å–å½“å‰è¡Œå­—ç¬¦é¢œè‰²ï¼ˆå®ç°é«˜äº®é€»è¾‘ï¼‰
   */
  private getCurrentLineCharColor(tone: Tone): string {
    // å½“å‰è¡Œçš„é«˜äº®é€»è¾‘ï¼šå”±è¿‡çš„éƒ¨åˆ†å…¨éƒ¨é«˜äº®
    if (this.mCurrentTime >= tone.begin) {
      return this.currentLineHighlightedTextColor; // é«˜äº®é¢œè‰²
    } else {
      return this.currentLineTextColor; // å½“å‰è¡Œæ­£å¸¸é¢œè‰²
    }
  }

  /**
   * è·å–æ™®é€šè¡Œé¢œè‰²
   */
  private getNormalLineColor(index: number): string {
    if (index < this.mIndexOfCurrentLine) {
      return this.previousLineTextColor; // å·²å”±è¿‡çš„è¡Œ
    } else {
      return this.upcomingLineTextColor; // æœªå”±çš„è¡Œ
    }
  }

  /**
   * è®¡ç®—è¡Œçš„é€æ˜åº¦ï¼ˆåŸºäºå¯è§æ€§å’Œè·ç¦»å½“å‰è¡Œçš„è¿œè¿‘ï¼‰
   */
  private getLineOpacity(index: number): number {
    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦åº”è¯¥æ¸²æŸ“è¯¥è¡Œ
    if (!this.shouldRenderLine(index)) {
      return 0.0; // å¦‚æœå¼€å…³ç¦ç”¨äº†è¯¥è¡Œï¼Œå®Œå…¨é€æ˜
    }

    const isVisible = this.isLineVisible(index);

    // ä¿åº•æœºåˆ¶ï¼šå¦‚æœæ‹–æ‹½æ—¶ï¼Œç¡®ä¿å½“å‰è¡Œé™„è¿‘çš„è¡Œè‡³å°‘æ˜¯å¯è§çš„
    if (this.mDraggingInProgress) {
      const currentIndex =
        this.originalCurrentLineIndex >= 0 ? this.originalCurrentLineIndex : this.mIndexOfCurrentLine;
      const distance = Math.abs(index - currentIndex);

      // å¼ºåˆ¶æ˜¾ç¤ºå½“å‰è¡Œé™„è¿‘çš„å‡ è¡Œï¼Œå³ä½¿ä½ç½®è®¡ç®—æœ‰é—®é¢˜
      if (distance <= 2) {
        return distance === 0 ? 1.0 : 0.8;
      }
    }

    // å¦‚æœä¸å¯è§ï¼Œè¿”å›é€æ˜
    if (!isVisible) {
      return 0.0;
    }

    // å¯è§çš„è¡Œæ ¹æ®è·ç¦»å½“å‰è¡Œçš„è¿œè¿‘è®¡ç®—é€æ˜åº¦
    const distance = Math.abs(index - this.mIndexOfCurrentLine);
    const maxVisibleLines = this.getMaxVisibleLines();
    const maxDistance = Math.floor(maxVisibleLines / 2);

    if (distance === 0) {
      return 1.0; // å½“å‰è¡Œå®Œå…¨ä¸é€æ˜
    } else if (distance <= maxDistance) {
      // ä½¿ç”¨æ›´å¹³æ»‘çš„é€æ˜åº¦æ¸å˜
      const fadeRatio = distance / maxDistance;
      return Math.max(0.2, 1.0 - (fadeRatio * 0.7)); // ä»1.0æ¸å˜åˆ°0.3
    } else if (distance <= maxDistance + 1) {
      // è¾¹ç•Œè¡Œä½¿ç”¨å¾ˆä½çš„é€æ˜åº¦ï¼Œç¡®ä¿å¹³æ»‘è¿‡æ¸¡
      return 0.1;
    } else {
      return 0.0; // è¶…å‡ºèŒƒå›´çš„è¡Œå®Œå…¨é€æ˜
    }
  }

  /**
   * è®¡ç®—è¡Œçš„ç¼©æ”¾æ¯”ä¾‹
   */
  private getLineScale(index: number): number {
    if (index === this.mIndexOfCurrentLine) {
      return 1.1; // å½“å‰è¡Œç¨å¾®æ”¾å¤§ï¼Œçªå‡ºæ˜¾ç¤º
    } else {
      const distance = Math.abs(index - this.mIndexOfCurrentLine);
      // è·ç¦»å½“å‰è¡Œè¶Šè¿œï¼Œç¼©æ”¾è¶Šå°ï¼Œä½†ä¿æŒæœ€å°å€¼
      return Math.max(0.95, 1.0 - (distance * 0.03));
    }
  }

  /**
   * è®¡ç®—è¿‡æ¸¡è¡Œçš„ç¼©æ”¾æ¯”ä¾‹
   */
  private getTransitioningLineScale(index: number): number {
    // è¿‡æ¸¡è¡Œç›´æ¥ä½¿ç”¨ç›®æ ‡ä½ç½®çš„ç¼©æ”¾æ¯”ä¾‹ï¼ˆæ™®é€šè¡Œå¤§å°ï¼‰
    const distance = Math.abs(index - this.mIndexOfCurrentLine);
    return Math.max(0.95, 1.0 - (distance * 0.03));
  }

  /**
   * è·å–è¿‡æ¸¡è¡Œçš„Yä½ç½®ï¼ˆä½¿ç”¨åŠ¨ç”»æ’å€¼ï¼‰
   */
  private getTransitioningYPosition(): number {
    // åœ¨åŠ¨ç”»åˆšå¼€å§‹æ—¶è¿”å›èµ·å§‹ä½ç½®ï¼Œç„¶åå¿«é€Ÿåˆ‡æ¢åˆ°ç›®æ ‡ä½ç½®è§¦å‘åŠ¨ç”»
    // ä½¿ç”¨animationKeyæ¥åˆ¤æ–­æ˜¯å¦æ˜¯æ–°åŠ¨ç”»çš„å¼€å§‹
    const currentTime = Date.now();
    const timeSinceAnimation = currentTime - this.animationKey;
    const isInStartPhase = timeSinceAnimation < 50;
    const position = isInStartPhase ? this.transitioningFromY : this.transitioningToY;

    LogUtils.d(`LyricsView: ğŸ”„ getTransitioningYPosition - phase: ${isInStartPhase ? 'START' :
      'TARGET'}, position: ${position}, timeSince: ${timeSinceAnimation}ms, fromY: ${this.transitioningFromY}, toY: ${this.transitioningToY}`);

    return position;
  }

  /**
   * è·å–æ–°å½“å‰è¡Œçš„Yä½ç½®
   */
  private getNewCurrentYPosition(): number {
    // åœ¨åŠ¨ç”»åˆšå¼€å§‹æ—¶è¿”å›èµ·å§‹ä½ç½®ï¼Œç„¶åå¿«é€Ÿåˆ‡æ¢åˆ°ç›®æ ‡ä½ç½®è§¦å‘åŠ¨ç”»
    const currentTime = Date.now();
    const timeSinceAnimation = currentTime - this.animationKey;
    const isInStartPhase = timeSinceAnimation < 50;
    const position = isInStartPhase ? this.newCurrentFromY : this.newCurrentToY;

    LogUtils.d(`LyricsView: ğŸ†• getNewCurrentYPosition - phase: ${isInStartPhase ? 'START' :
      'TARGET'}, position: ${position}, timeSince: ${timeSinceAnimation}ms, fromY: ${this.newCurrentFromY}, toY: ${this.newCurrentToY}`);

    return position;
  }

  /**
   * è·å–æ–°å½“å‰è¡Œçš„ç¼©æ”¾æ¯”ä¾‹
   */
  private getNewCurrentScale(): number {
    if (this.styleTransitioning) {
      return 1.1; // æ ·å¼è¿‡æ¸¡æ—¶ä½¿ç”¨å½“å‰è¡Œç¼©æ”¾
    } else {
      return 1.0; // ä½ç½®è¿‡æ¸¡æ—¶ä½¿ç”¨æ™®é€šè¡Œç¼©æ”¾
    }
  }

  /**
   * è·å–é«˜äº®å±‚çš„é€æ˜åº¦
   */
  private getHighlightOpacity(): number {
    return this.styleTransitioning ? 1.0 : 0.0;
  }

  /**
   * è·å–è¿‡æ¸¡ä¸­çš„å­—ä½“å¤§å°
   */
  private getTransitioningFontSize(): number {
    if (this.styleTransitioning) {
      return this.currentLineTextSize; // è¿‡æ¸¡åˆ°å½“å‰è¡Œå­—ä½“å¤§å°
    } else {
      return this.textSize; // å¼€å§‹æ—¶ä½¿ç”¨æ™®é€šè¡Œå­—ä½“å¤§å°
    }
  }

  /**
   * è·å–è¿‡æ¸¡ä¸­çš„æ–‡å­—é¢œè‰²
   */
  private getTransitioningTextColor(): string {
    if (this.styleTransitioning) {
      return this.currentLineTextColor; // è¿‡æ¸¡åˆ°å½“å‰è¡Œé¢œè‰²
    } else {
      return this.upcomingLineTextColor; // å¼€å§‹æ—¶ä½¿ç”¨æœªå”±è¡Œé¢œè‰²
    }
  }

  /**
   * è·å–è¿‡æ¸¡ä¸­çš„å­—ä½“ç²—ç»†
   */
  private getTransitioningFontWeight(): FontWeight {
    if (this.styleTransitioning) {
      return FontWeight.Bold; // è¿‡æ¸¡åˆ°å½“å‰è¡Œå­—é‡
    } else {
      return FontWeight.Normal; // å¼€å§‹æ—¶ä½¿ç”¨æ™®é€šè¡Œå­—é‡
    }
  }

  /**
   * æ ¹æ®è§¦æ‘¸Yåæ ‡è®¡ç®—å¯¹åº”çš„æ­Œè¯è¡Œç´¢å¼•
   * @param touchY è§¦æ‘¸ç‚¹çš„Yåæ ‡
   * @return å¯¹åº”çš„æ­Œè¯è¡Œç´¢å¼•ï¼Œå¦‚æœæ— æ•ˆåˆ™è¿”å›-1
   */
  private calculateLineIndexByTouchY(touchY: number): number {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines || lyricsModel.lines.length === 0) {
      return -1;
    }

    const lineHeight = this.getLineHeight();
    const centerY = (this.actualViewHeight / 2) - (lineHeight / 2);

    // è®¡ç®—è§¦æ‘¸ç‚¹ç›¸å¯¹äºå½“å‰è¡Œä¸­å¿ƒçš„åç§»
    const offsetFromCenter = touchY - centerY;
    const lineOffset = Math.round(offsetFromCenter / lineHeight);

    // è®¡ç®—ç›®æ ‡è¡Œç´¢å¼•
    const targetLineIndex = this.mIndexOfCurrentLine + lineOffset;

    // ç¡®ä¿ç´¢å¼•åœ¨æœ‰æ•ˆèŒƒå›´å†…
    if (targetLineIndex >= 0 && targetLineIndex < lyricsModel.lines.length) {
      return targetLineIndex;
    }

    return -1;
  }

  /**
   * æ ¹æ®æ­Œè¯è¡Œç´¢å¼•è·å–å¯¹åº”çš„å¼€å§‹æ—¶é—´
   * @param lineIndex æ­Œè¯è¡Œç´¢å¼•
   * @return å¯¹åº”çš„å¼€å§‹æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œå¦‚æœæ— æ•ˆåˆ™è¿”å›-1
   */
  private getLineStartTime(lineIndex: number): number {
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (!lyricsModel || !lyricsModel.lines || lineIndex < 0 || lineIndex >= lyricsModel.lines.length) {
      return -1;
    }

    return lyricsModel.lines[lineIndex].getStartTime();
  }

  /**
   * å¤„ç†æ‹–æ‹½å¼€å§‹äº‹ä»¶
   * @param touchY åˆå§‹è§¦æ‘¸Yåæ ‡
   */
  private handleDragStart(touchY: number): void {
    if (!this.enableDragging) {
      return;
    }

    LogUtils.d('LyricsView: Drag start');
    this.mDraggingInProgress = true;
    this.initialTouchY = touchY;
    this.currentTouchY = touchY;
    this.dragOffset = 0;
    this.dragLineOffset = 0;
    this.originalCurrentLineIndex = this.mIndexOfCurrentLine; // è®°å½•æ‹–æ‹½å¼€å§‹æ—¶çš„å½“å‰è¡Œ

    // é€šè¿‡EventBusé€šçŸ¥æ‹–æ‹½å¼€å§‹
    this.eventBus.emit(LyricsEvents.DRAG_START);
  }

  /**
   * å¤„ç†æ‹–æ‹½ç§»åŠ¨äº‹ä»¶
   * @param touchY å½“å‰è§¦æ‘¸Yåæ ‡
   */
  private handleDragMove(touchY: number): void {
    if (!this.enableDragging || !this.mDraggingInProgress) {
      return;
    }

    this.currentTouchY = touchY;
    // è®¡ç®—Yè½´ç§»åŠ¨è·ç¦»
    const deltaY = touchY - this.initialTouchY;

    // æ ¹æ®Yè½´ç§»åŠ¨è·ç¦»è®¡ç®—æ­Œè¯è¡Œåç§»é‡
    // ä½¿ç”¨å®é™…çš„æ­Œè¯è¡Œé«˜åº¦æ¥è®¡ç®—åç§»é‡
    const lineHeight = this.getLineHeight();
    const rawLineOffset = Math.round(deltaY / lineHeight);

    // è®¡ç®—æ‹–æ‹½è¾¹ç•Œé™åˆ¶
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (lyricsModel && lyricsModel.lines) {
      // è®¡ç®—æ›´ä¿å®ˆçš„è¾¹ç•Œé™åˆ¶
      const totalLines = lyricsModel.lines.length;

      // å‘ä¸Šæ‹–æ‹½é™åˆ¶ï¼šä¸èƒ½è¶…è¿‡ç¬¬ä¸€è¡Œ
      const maxUpwardOffset = this.originalCurrentLineIndex;

      // å‘ä¸‹æ‹–æ‹½é™åˆ¶ï¼šä¸èƒ½è¶…è¿‡æœ€åä¸€è¡Œ
      const maxDownwardOffset = totalLines - 1 - this.originalCurrentLineIndex;

      // é™åˆ¶æ‹–æ‹½åç§»é‡åœ¨å®‰å…¨èŒƒå›´å†…
      this.dragLineOffset = Math.max(-maxDownwardOffset, Math.min(maxUpwardOffset, rawLineOffset));

      LogUtils.d(`LyricsView: Dragging, deltaY: ${deltaY}, rawOffset: ${rawLineOffset}, limitedOffset: ${this.dragLineOffset}, bounds: [${-maxDownwardOffset}, ${maxUpwardOffset}]`);

      // ç»Ÿè®¡å¯è§è¡Œæ•°ï¼ˆè°ƒè¯•ç”¨ï¼‰
      this.logVisibleLinesCount();

      // å¼ºåˆ¶è§¦å‘UIæ›´æ–°ï¼Œè®©å¯è§æ€§æ£€æŸ¥ç”Ÿæ•ˆ
      this.mForceUpdateUi = LyricsView.UPDATE_UI_TYPE_NORMAL;
    } else {
      this.dragLineOffset = 0;
    }
  }

  /**
   * å¤„ç†æ‹–æ‹½ç»“æŸäº‹ä»¶
   * @param touchY æœ€ç»ˆè§¦æ‘¸ç‚¹çš„Yåæ ‡
   */
  private handleDragEnd(touchY: number): void {
    if (!this.enableDragging) {
      return;
    }

    LogUtils.d('LyricsView: Drag end');
    this.mDraggingInProgress = false;

    // è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡è¡Œç´¢å¼•
    const lyricsModel = this.mLyricMachine?.getLyricsModel();
    if (lyricsModel && lyricsModel.lines) {
      const finalLineIndex = this.originalCurrentLineIndex - this.dragLineOffset;
      const clampedIndex = Math.max(0, Math.min(finalLineIndex, lyricsModel.lines.length - 1));
      const startTime = this.getLineStartTime(clampedIndex);

      if (startTime >= 0) {
        LogUtils.d(`LyricsView: Final drag line ${clampedIndex}, time ${startTime}ms`);

        // é€šè¿‡EventBusé€šçŸ¥æœ€ç»ˆæ‹–æ‹½ä½ç½®
        this.eventBus.emit(LyricsEvents.DRAG_END, startTime);
      } else {
        LogUtils.d('LyricsView: Failed to get start time for final position');
      }
    } else {
      LogUtils.d('LyricsView: No lyrics model available');
    }

    // é‡ç½®æ‹–æ‹½çŠ¶æ€
    this.dragOffset = 0;
    this.initialTouchY = 0;
    this.currentTouchY = 0;
    this.dragLineOffset = 0;
    this.originalCurrentLineIndex = -1;
  }

  /**
   * Renders the prelude end position indicator
   */
  @Builder
  PreludeIndicatorBuilder() {
    if (this.enablePreludeEndPositionIndicator && this.mLyricMachine?.getLyricsModel() &&
      this.getPreludeCountDown() > 0) {
      Row() {
        // Indicator 1
        Circle({
          width: this.preludeEndPositionIndicatorRadius * 2,
          height: this.preludeEndPositionIndicatorRadius * 2
        })
          .fill(this.preludeEndPositionIndicatorColor)

        if (this.getPreludeCountDown() >= 2) {
          // Indicator 2
          Circle({
            width: this.preludeEndPositionIndicatorRadius * 2,
            height: this.preludeEndPositionIndicatorRadius * 2
          })
            .fill(this.preludeEndPositionIndicatorColor)
            .margin({ left: this.preludeEndPositionIndicatorRadius * 2 })
        }

        if (this.getPreludeCountDown() >= 3) {
          // Indicator 3 (with blinking effect)
          Circle({
            width: this.preludeEndPositionIndicatorRadius * 2,
            height: this.preludeEndPositionIndicatorRadius * 2
          })
            .fill(this.preludeEndPositionIndicatorColor)
            .margin({ left: this.preludeEndPositionIndicatorRadius * 2 })
            .opacity((this.getPreludeCountDown() % 2 === 1 || this.mCurrentTime < 2000) ? 1 : 0)
        }
      }
      .width('100%')
      .justifyContent(this.getRowJustifyContent())
      .margin({ top: this.preludeEndPositionIndicatorPaddingTop })
    }
  }

  build() {
    Column() {
      // Prelude indicator
      this.PreludeIndicatorBuilder()

      // Main lyrics content
      if (this.uninitializedOrNoLyrics()) {
        this.NoLyricsBuilder()
      } else {
        // ä½¿ç”¨ Stack æ¥æ”¯æŒç»å¯¹å®šä½
        Stack() {
          if (this.mLyricMachine?.getLyricsModel()?.lines) {
            ForEach(this.mLyricMachine?.getLyricsModel()?.lines, (line: LyricsLineModel, index: number) => {
              // æ ¹æ®å¼€å…³å†³å®šæ˜¯å¦ç»˜åˆ¶è¯¥è¡Œ
              if (this.shouldRenderLine(index)) {
                this.EnhancedLyricsLineBuilder(line, index)
              }
            })
          }
        }
        .width('100%')
        .height('100%')
        .alignContent(Alignment.TopStart) // ä»é¡¶éƒ¨å¼€å§‹å®šä½
      }
    }
    .width('100%')
    .height('90%')
    .margin({ top: this.paddingTop })
    .onTouch((event: TouchEvent) => {
      if (!this.enableDragging) {
        return false;
      }

      switch (event.type) {
        case TouchType.Down:
          this.handleDragStart(event.touches[0].y);
          return true;
        case TouchType.Move:
          this.handleDragMove(event.touches[0].y);
          return true;
        case TouchType.Up:
        case TouchType.Cancel:
          this.handleDragEnd(event.touches[0].y);
          return true;
        default:
          return false;
      }
    })
    .onAreaChange((oldValue: Area, newValue: Area) => {
      // åŠ¨æ€è·å–ç»„ä»¶å®é™…å°ºå¯¸
      if (newValue.height && typeof newValue.height === 'number') {
        this.actualViewHeight = newValue.height;
        LogUtils.d(`LyricsView: Component height measured: ${this.actualViewHeight}`);
        // é«˜åº¦å˜åŒ–åï¼Œä½ç½®ä¼šè‡ªåŠ¨é‡æ–°è®¡ç®—ï¼Œä¸éœ€è¦æ‰‹åŠ¨æ»šåŠ¨
      }
      if (newValue.width && typeof newValue.width === 'number') {
        this.actualViewWidth = newValue.width;
        LogUtils.d(`LyricsView: Component width measured: ${this.actualViewWidth}`);
      }
    })
    .onAppear(() => {
      LogUtils.d('LyricsView: Component appeared, setting up event listeners');
      this.setupEventListeners();

      // é€šçŸ¥å¤–éƒ¨ç»„ä»¶LyricsViewå·²å‡†å¤‡å¥½
      setTimeout(() => {
        LogUtils.d('LyricsView: Ready for events');
      }, 10);
    })
    .onDisAppear(() => {
      LogUtils.d('LyricsView: Component disappearing, cleaning up');
      this.removeEventListeners();
      this.resetCompletely(); // å®Œå…¨æ¸…ç†
    })
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
   */
  private setupEventListeners(): void {
    LogUtils.d('LyricsView: Setting up event listeners');

    // åˆå§‹åŒ–LyricMachine
    this.initLyricMachine();

    // ç›‘å¬æ­Œè¯æ•°æ®è®¾ç½®äº‹ä»¶
    const setLyricDataHandler = (lyricModel: LyricModel) => {
      if (this.mLyricMachine) {
        this.mLyricMachine.prepare(lyricModel);
        // mLyricsModel removed - data now managed by mLyricMachine
        this.forceCheckLineWrap();
        LogUtils.d(`LyricsView: Lyric data set successfully, getLyricsModel: ${!!this.mLyricMachine.getLyricsModel()}`);
      } else {
        LogUtils.e('LyricsView: mLyricMachine is null when receiving SET_LYRIC_DATA event');
      }
    };
    this.eventBus.on(LyricsEvents.SET_LYRIC_DATA, setLyricDataHandler);

    // ç›‘å¬è¿›åº¦æ›´æ–°äº‹ä»¶
    this.eventBus.on(LyricsEvents.SET_PROGRESS, (progress: number) => {
      if (this.mLyricMachine) {
        this.mLyricMachine.setProgress(progress);
      }
    });

    // ç›‘å¬é‡ç½®äº‹ä»¶
    this.eventBus.on(LyricsEvents.RESET, () => {
      LogUtils.d('LyricsView: Received RESET event');
      if (this.mLyricMachine) {
        this.mLyricMachine.reset();
      }
    });

    // ç›‘å¬åˆ·æ–°UIäº‹ä»¶
    this.eventBus.on(LyricsEvents.REQUEST_REFRESH, () => {
      LogUtils.d('LyricsView: Received REQUEST_REFRESH event');
      this.requestRefreshUi();
    });
  }

  /**
   * ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
   */
  private removeEventListeners(): void {
    LogUtils.d('LyricsView: Removing event listeners');
    // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„ç§»é™¤é€»è¾‘ï¼Œä½†ç”±äºEventBusæ˜¯å•ä¾‹ï¼Œ
    // æˆ‘ä»¬å¯èƒ½éœ€è¦ä¿å­˜å›è°ƒå‡½æ•°çš„å¼•ç”¨æ¥æ­£ç¡®ç§»é™¤
  }

  /**
   * åˆå§‹åŒ–LyricMachine
   */
  private initLyricMachine(): void {
    // åˆ›å»ºLyricMachineå¹¶å‡†å¤‡æ•°æ®
    if (!this.mLyricMachine) {
      LogUtils.d('LyricsView: Creating new LyricMachine');

      // åˆ›å»ºä¸€ä¸ªç®€å•çš„ç›‘å¬å™¨å®ç°
      class LyricListenerImpl implements OnLyricListener {
        private lyricsView: LyricsView;

        constructor(lyricsView: LyricsView) {
          this.lyricsView = lyricsView;
        }

        resetUi(): void {
          LogUtils.d('LyricsView: resetUi called');
          this.lyricsView.reset();
        }

        requestRefreshUi(): void {
          this.lyricsView.requestRefreshUi();
        }
      }

      const listener = new LyricListenerImpl(this);
      this.mLyricMachine = new LyricMachine(listener);
      LogUtils.d(`LyricsView: LyricMachine created successfully, initial ready state: ${this.mLyricMachine.isReady()}`);
    } else {
      LogUtils.d('LyricsView: LyricMachine already exists');
    }
  }
}
